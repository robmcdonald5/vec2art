//! Auto-generated TypeScript interfaces from Rust parameter registry
//! DO NOT EDIT MANUALLY - This file is generated by the build process
//!
//! Generated from: wasm/vectorize-core/src/parameters/registry.rs
//! Regenerate with: cargo run --bin generate-frontend-types

export interface VectorizerConfig {
	// ==================== CORE PARAMETERS ====================
	/**
	 * Detail level (0.0 = sparse, 1.0 = detailed)
	 * Default: 0.8
	 */
	detail: number;

	/**
	 * Stroke width at 1080p reference resolution
	 * Default: 1.5
	 */
	stroke_px_at_1080p: number;

	// ==================== QUALITY PARAMETERS ====================
	/**
	 * Douglas-Peucker epsilon for path simplification
	 * Applicable backends: [Centerline]
	 * Default: 1
	 */
	douglas_peucker_epsilon?: number;

	/**
	 * Enable multi-pass processing for enhanced quality
	 * Applicable backends: [Edge]
	 * Default: false
	 */
	enable_multipass?: boolean;

	/**
	 * Maximum total processing time budget in milliseconds
	 * Default: 180000
	 */
	max_processing_time_ms: number;

	/**
	 * Minimum branch length for centerline tracing in pixels
	 * Applicable backends: [Centerline]
	 * Default: 8
	 */
	min_branch_length?: number;

	/**
	 * Range sigma for bilateral noise filtering (higher = less edge preservation)
	 * Applicable backends: [Edge, Centerline]
	 * Requires: ["noise_filtering"]
	 * Default: 50
	 */
	noise_filter_range_sigma?: number;

	/**
	 * Spatial sigma for bilateral noise filtering (higher = more smoothing)
	 * Applicable backends: [Edge, Centerline]
	 * Requires: ["noise_filtering"]
	 * Default: 2
	 */
	noise_filter_spatial_sigma?: number;

	/**
	 * Enable content-aware noise filtering
	 * Applicable backends: [Edge, Centerline]
	 * Default: false
	 */
	noise_filtering?: boolean;

	/**
	 * Number of processing passes (1-10)
	 * Applicable backends: [Edge]
	 * Requires: ["enable_multipass"]
	 * Default: 1
	 */
	pass_count?: number;

	/**
	 * Boundary simplification tolerance
	 * Applicable backends: [Superpixel]
	 * Requires: ["superpixel_simplify_boundaries"]
	 * Default: 1
	 */
	superpixel_boundary_epsilon?: number;

	/**
	 * Whether to simplify superpixel boundaries using Douglas-Peucker
	 * Applicable backends: [Superpixel]
	 * Default: true
	 */
	superpixel_simplify_boundaries?: boolean;

	// ==================== ALGORITHM PARAMETERS ====================
	/**
	 * Sensitivity parameter k for Sauvola thresholding
	 * Applicable backends: [Centerline]
	 * Requires: ["enable_adaptive_threshold"]
	 * Default: 0.3
	 */
	adaptive_threshold_k?: number;

	/**
	 * Window size for adaptive thresholding
	 * Applicable backends: [Centerline]
	 * Requires: ["enable_adaptive_threshold"]
	 * Default: 25
	 */
	adaptive_threshold_window_size?: number;

	/**
	 * Threshold for directional strength - skip pass if not beneficial
	 * Applicable backends: [Edge]
	 * Requires: ["enable_reverse_pass", "enable_diagonal_pass"]
	 * Default: 0.1
	 */
	directional_strength_threshold?: number;

	/**
	 * Whether to use adaptive sizing based on local variance
	 * Applicable backends: [Dots]
	 * Default: true
	 */
	dot_adaptive_sizing?: boolean;

	/**
	 * Background color tolerance for background detection
	 * Applicable backends: [Dots]
	 * Default: 0.1
	 */
	dot_background_tolerance?: number;

	/**
	 * Minimum gradient strength required to place a dot
	 * Applicable backends: [Dots]
	 * Default: 0.105
	 */
	dot_density_threshold?: number;

	/**
	 * Enable gradient-based sizing for dot scaling based on local image gradients
	 * Applicable backends: [Dots]
	 * Default: true
	 */
	dot_gradient_based_sizing?: boolean;

	/**
	 * Enable Poisson disk sampling for natural dot distribution
	 * Applicable backends: [Dots]
	 * Default: false
	 */
	dot_poisson_disk_sampling?: boolean;

	/**
	 * Enable adaptive thresholding for centerline backend
	 * Applicable backends: [Centerline]
	 * Default: true
	 */
	enable_adaptive_threshold?: boolean;

	/**
	 * Enable diagonal direction processing (NW→SE, NE→SW)
	 * Applicable backends: [Edge]
	 * Default: false
	 */
	enable_diagonal_pass?: boolean;

	/**
	 * Enable reverse direction processing (R→L, B→T)
	 * Applicable backends: [Edge]
	 * Default: false
	 */
	enable_reverse_pass?: boolean;

	/**
	 * Number of superpixels to generate
	 * Applicable backends: [Superpixel]
	 * Default: 275
	 */
	num_superpixels?: number;

	/**
	 * SLIC compactness parameter - higher values create more regular shapes
	 * Applicable backends: [Superpixel]
	 * Default: 10
	 */
	superpixel_compactness?: number;

	/**
	 * Pattern for placing initial superpixel cluster centers
	 * Applicable backends: [Superpixel]
	 * Default: poisson
	 */
	superpixel_initialization_pattern?: 'square' | 'hexagonal' | 'poisson';

	/**
	 * SLIC iterations for convergence
	 * Applicable backends: [Superpixel]
	 * Default: 10
	 */
	superpixel_slic_iterations?: number;

	// ==================== STYLE PARAMETERS ====================
	/**
	 * Maximum dot radius in pixels
	 * Applicable backends: [Dots]
	 * Default: 3
	 */
	dot_max_radius?: number;

	/**
	 * Minimum dot radius in pixels
	 * Applicable backends: [Dots]
	 * Default: 0.5
	 */
	dot_min_radius?: number;

	/**
	 * Enable EDT-based width modulation for centerline SVG strokes
	 * Applicable backends: [Centerline]
	 * Default: false
	 */
	enable_width_modulation?: boolean;

	/**
	 * Whether to fill superpixel regions with solid color
	 * Applicable backends: [Superpixel]
	 * Default: true
	 */
	superpixel_fill_regions?: boolean;

	/**
	 * Whether to stroke superpixel region boundaries
	 * Applicable backends: [Superpixel]
	 * Default: true
	 */
	superpixel_stroke_regions?: boolean;

	// ==================== COLOR PARAMETERS ====================
	/**
	 * Whether to preserve original pixel colors in dot output
	 * Applicable backends: [Dots]
	 * Default: true
	 */
	dot_preserve_colors?: boolean;

	/**
	 * Whether to preserve original colors in superpixel regions
	 * Applicable backends: [Superpixel]
	 * Default: true
	 */
	superpixel_preserve_colors?: boolean;
}

export interface EdgeBackendConfig
	extends Pick<
		VectorizerConfig,
		| 'noise_filtering'
		| 'enable_reverse_pass'
		| 'noise_filter_spatial_sigma'
		| 'noise_filter_range_sigma'
		| 'detail'
		| 'max_processing_time_ms'
		| 'stroke_px_at_1080p'
		| 'enable_diagonal_pass'
		| 'pass_count'
		| 'directional_strength_threshold'
		| 'enable_multipass'
	> {}

export interface CenterlineBackendConfig
	extends Pick<
		VectorizerConfig,
		| 'noise_filtering'
		| 'adaptive_threshold_window_size'
		| 'noise_filter_spatial_sigma'
		| 'enable_width_modulation'
		| 'noise_filter_range_sigma'
		| 'detail'
		| 'douglas_peucker_epsilon'
		| 'max_processing_time_ms'
		| 'stroke_px_at_1080p'
		| 'adaptive_threshold_k'
		| 'min_branch_length'
		| 'enable_adaptive_threshold'
	> {}

export interface SuperpixelBackendConfig
	extends Pick<
		VectorizerConfig,
		| 'superpixel_preserve_colors'
		| 'num_superpixels'
		| 'superpixel_boundary_epsilon'
		| 'superpixel_simplify_boundaries'
		| 'detail'
		| 'superpixel_compactness'
		| 'max_processing_time_ms'
		| 'stroke_px_at_1080p'
		| 'superpixel_slic_iterations'
		| 'superpixel_initialization_pattern'
		| 'superpixel_stroke_regions'
		| 'superpixel_fill_regions'
	> {}

export interface DotsBackendConfig
	extends Pick<
		VectorizerConfig,
		| 'dot_density_threshold'
		| 'dot_preserve_colors'
		| 'dot_adaptive_sizing'
		| 'dot_poisson_disk_sampling'
		| 'dot_max_radius'
		| 'dot_background_tolerance'
		| 'dot_gradient_based_sizing'
		| 'detail'
		| 'max_processing_time_ms'
		| 'stroke_px_at_1080p'
		| 'dot_min_radius'
	> {}

export const PARAMETER_METADATA = {
	noise_filtering: {
		name: 'noise_filtering',
		description: 'Enable content-aware noise filtering',
		category: 'quality',
		applicableBackends: "['edge', 'centerline']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	},
	enable_reverse_pass: {
		name: 'enable_reverse_pass',
		description: 'Enable reverse direction processing (R→L, B→T)',
		category: 'algorithm',
		applicableBackends: "['edge']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	},
	adaptive_threshold_window_size: {
		name: 'adaptive_threshold_window_size',
		description: 'Window size for adaptive thresholding',
		category: 'algorithm',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'integer',
		min: 15,
		max: 45,
		requires: ['enable_adaptive_threshold'],
		defaultValue: 25
	},
	dot_density_threshold: {
		name: 'dot_density_threshold',
		description: 'Minimum gradient strength required to place a dot',
		category: 'algorithm',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'float',
		min: 0,
		max: 1,
		precision: 3,
		defaultValue: 0.105
	},
	dot_preserve_colors: {
		name: 'dot_preserve_colors',
		description: 'Whether to preserve original pixel colors in dot output',
		category: 'color',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	superpixel_preserve_colors: {
		name: 'superpixel_preserve_colors',
		description: 'Whether to preserve original colors in superpixel regions',
		category: 'color',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	num_superpixels: {
		name: 'num_superpixels',
		description: 'Number of superpixels to generate',
		category: 'algorithm',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'integer',
		min: 20,
		max: 1000,
		defaultValue: 275
	},
	noise_filter_spatial_sigma: {
		name: 'noise_filter_spatial_sigma',
		description: 'Spatial sigma for bilateral noise filtering (higher = more smoothing)',
		category: 'quality',
		applicableBackends: "['edge', 'centerline']",
		backendSpecific: true,
		type: 'float',
		min: 0.5,
		max: 5,
		precision: 1,
		requires: ['noise_filtering'],
		defaultValue: 2
	},
	dot_adaptive_sizing: {
		name: 'dot_adaptive_sizing',
		description: 'Whether to use adaptive sizing based on local variance',
		category: 'algorithm',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	dot_poisson_disk_sampling: {
		name: 'dot_poisson_disk_sampling',
		description: 'Enable Poisson disk sampling for natural dot distribution',
		category: 'algorithm',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	},
	enable_width_modulation: {
		name: 'enable_width_modulation',
		description: 'Enable EDT-based width modulation for centerline SVG strokes',
		category: 'style',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	},
	dot_max_radius: {
		name: 'dot_max_radius',
		description: 'Maximum dot radius in pixels',
		category: 'style',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'float',
		min: 0.5,
		max: 20,
		precision: 1,
		defaultValue: 3
	},
	dot_background_tolerance: {
		name: 'dot_background_tolerance',
		description: 'Background color tolerance for background detection',
		category: 'algorithm',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'float',
		min: 0,
		max: 1,
		precision: 2,
		defaultValue: 0.1
	},
	superpixel_boundary_epsilon: {
		name: 'superpixel_boundary_epsilon',
		description: 'Boundary simplification tolerance',
		category: 'quality',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'float',
		min: 0.5,
		max: 3,
		precision: 1,
		requires: ['superpixel_simplify_boundaries'],
		defaultValue: 1
	},
	dot_gradient_based_sizing: {
		name: 'dot_gradient_based_sizing',
		description: 'Enable gradient-based sizing for dot scaling based on local image gradients',
		category: 'algorithm',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	noise_filter_range_sigma: {
		name: 'noise_filter_range_sigma',
		description: 'Range sigma for bilateral noise filtering (higher = less edge preservation)',
		category: 'quality',
		applicableBackends: "['edge', 'centerline']",
		backendSpecific: true,
		type: 'float',
		min: 10,
		max: 200,
		precision: 1,
		requires: ['noise_filtering'],
		defaultValue: 50
	},
	superpixel_simplify_boundaries: {
		name: 'superpixel_simplify_boundaries',
		description: 'Whether to simplify superpixel boundaries using Douglas-Peucker',
		category: 'quality',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	detail: {
		name: 'detail',
		description: 'Detail level (0.0 = sparse, 1.0 = detailed)',
		category: 'core',
		applicableBackends: "['edge', 'centerline', 'superpixel', 'dots']",
		backendSpecific: false,
		type: 'float',
		min: 0,
		max: 1,
		precision: 2,
		defaultValue: 0.8
	},
	superpixel_compactness: {
		name: 'superpixel_compactness',
		description: 'SLIC compactness parameter - higher values create more regular shapes',
		category: 'algorithm',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'float',
		min: 1,
		max: 50,
		precision: 1,
		defaultValue: 10
	},
	douglas_peucker_epsilon: {
		name: 'douglas_peucker_epsilon',
		description: 'Douglas-Peucker epsilon for path simplification',
		category: 'quality',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'float',
		min: 0.1,
		max: 5,
		precision: 1,
		defaultValue: 1
	},
	max_processing_time_ms: {
		name: 'max_processing_time_ms',
		description: 'Maximum total processing time budget in milliseconds',
		category: 'quality',
		applicableBackends: "['edge', 'centerline', 'superpixel', 'dots']",
		backendSpecific: false,
		type: 'integer',
		min: 1000,
		max: 300000,
		defaultValue: 180000
	},
	stroke_px_at_1080p: {
		name: 'stroke_px_at_1080p',
		description: 'Stroke width at 1080p reference resolution',
		category: 'core',
		applicableBackends: "['edge', 'centerline', 'superpixel', 'dots']",
		backendSpecific: false,
		type: 'float',
		min: 0.1,
		max: 20,
		precision: 1,
		defaultValue: 1.5
	},
	adaptive_threshold_k: {
		name: 'adaptive_threshold_k',
		description: 'Sensitivity parameter k for Sauvola thresholding',
		category: 'algorithm',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'float',
		min: 0.1,
		max: 0.9,
		precision: 2,
		requires: ['enable_adaptive_threshold'],
		defaultValue: 0.3
	},
	min_branch_length: {
		name: 'min_branch_length',
		description: 'Minimum branch length for centerline tracing in pixels',
		category: 'quality',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'float',
		min: 2,
		max: 30,
		precision: 1,
		defaultValue: 8
	},
	dot_min_radius: {
		name: 'dot_min_radius',
		description: 'Minimum dot radius in pixels',
		category: 'style',
		applicableBackends: "['dots']",
		backendSpecific: true,
		type: 'float',
		min: 0.1,
		max: 5,
		precision: 1,
		defaultValue: 0.5
	},
	enable_diagonal_pass: {
		name: 'enable_diagonal_pass',
		description: 'Enable diagonal direction processing (NW→SE, NE→SW)',
		category: 'algorithm',
		applicableBackends: "['edge']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	},
	superpixel_slic_iterations: {
		name: 'superpixel_slic_iterations',
		description: 'SLIC iterations for convergence',
		category: 'algorithm',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'integer',
		min: 5,
		max: 15,
		defaultValue: 10
	},
	superpixel_initialization_pattern: {
		name: 'superpixel_initialization_pattern',
		description: 'Pattern for placing initial superpixel cluster centers',
		category: 'algorithm',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'enum',
		variants: ['square', 'hexagonal', 'poisson'],
		defaultValue: 'poisson'
	},
	pass_count: {
		name: 'pass_count',
		description: 'Number of processing passes (1-10)',
		category: 'quality',
		applicableBackends: "['edge']",
		backendSpecific: true,
		type: 'integer',
		min: 1,
		max: 10,
		requires: ['enable_multipass'],
		defaultValue: 1
	},
	superpixel_stroke_regions: {
		name: 'superpixel_stroke_regions',
		description: 'Whether to stroke superpixel region boundaries',
		category: 'style',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	superpixel_fill_regions: {
		name: 'superpixel_fill_regions',
		description: 'Whether to fill superpixel regions with solid color',
		category: 'style',
		applicableBackends: "['superpixel']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	directional_strength_threshold: {
		name: 'directional_strength_threshold',
		description: 'Threshold for directional strength - skip pass if not beneficial',
		category: 'algorithm',
		applicableBackends: "['edge']",
		backendSpecific: true,
		type: 'float',
		min: 0,
		max: 1,
		precision: 2,
		requires: ['enable_reverse_pass', 'enable_diagonal_pass'],
		defaultValue: 0.1
	},
	enable_adaptive_threshold: {
		name: 'enable_adaptive_threshold',
		description: 'Enable adaptive thresholding for centerline backend',
		category: 'algorithm',
		applicableBackends: "['centerline']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: true
	},
	enable_multipass: {
		name: 'enable_multipass',
		description: 'Enable multi-pass processing for enhanced quality',
		category: 'quality',
		applicableBackends: "['edge']",
		backendSpecific: true,
		type: 'boolean',
		defaultValue: false
	}
} as const;

export type ParameterMetadata = (typeof PARAMETER_METADATA)[keyof typeof PARAMETER_METADATA];

export type VectorizerBackend = 'edge' | 'centerline' | 'superpixel' | 'dots';

export type ParameterCategory = 'core' | 'quality' | 'algorithm' | 'style' | 'color' | 'advanced';

/**
 * Get all parameters applicable to a specific backend
 */
export function getParametersForBackend(backend: VectorizerBackend): string[] {
	return Object.keys(PARAMETER_METADATA).filter((paramName) => {
		const metadata = PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];
		return metadata.applicableBackends.includes(backend);
	});
}

/**
 * Get parameters by category
 */
export function getParametersByCategory(category: ParameterCategory): string[] {
	return Object.keys(PARAMETER_METADATA).filter((paramName) => {
		const metadata = PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];
		return metadata.category === category;
	});
}

/**
 * Get parameter metadata by name
 */
export function getParameterMetadata(paramName: string): ParameterMetadata | undefined {
	return PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];
}

/**
 * Validate a parameter value against its metadata
 */
export function validateParameter(
	paramName: string,
	value: any
): { valid: boolean; error?: string } {
	const metadata = getParameterMetadata(paramName);
	if (!metadata) {
		return { valid: false, error: `Unknown parameter: ${paramName}` };
	}

	// Type checking based on parameter metadata
	switch (metadata.type) {
		case 'float':
		case 'integer':
			if (typeof value !== 'number' || isNaN(value)) {
				return { valid: false, error: `${paramName} must be a number` };
			}
			if (
				'min' in metadata &&
				'max' in metadata &&
				(value < metadata.min || value > metadata.max)
			) {
				return {
					valid: false,
					error: `${paramName} must be between ${metadata.min} and ${metadata.max}`
				};
			}
			break;
		case 'boolean':
			if (typeof value !== 'boolean') {
				return { valid: false, error: `${paramName} must be a boolean` };
			}
			break;
		case 'enum':
			if (
				typeof value !== 'string' ||
				!('variants' in metadata) ||
				!(metadata.variants as readonly string[]).includes(value)
			) {
				const variants =
					'variants' in metadata ? (metadata.variants as readonly string[]).join(', ') : 'unknown';
				return { valid: false, error: `${paramName} must be one of: ${variants}` };
			}
			break;
	}

	return { valid: true };
}
