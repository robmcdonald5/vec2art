<!DOCTYPE html>
<html>
<head>
    <title>WASM Threading Capability Test</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #e0e0e0; 
            max-width: 1000px;
            margin: 0 auto;
        }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            background: #2a2a2a; 
            border-radius: 8px;
        }
        .pass { color: #4caf50; }
        .fail { color: #f44336; }
        .warn { color: #ff9800; }
        .info { color: #2196f3; }
        pre { 
            background: #333; 
            padding: 10px; 
            border-radius: 4px; 
            overflow-x: auto;
        }
        button {
            background: #4fc3f7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #29b6f6; }
    </style>
</head>
<body>
    <h1>üßµ WASM Threading Capability Test</h1>
    
    <div class="section">
        <h2>üîç Environment Detection</h2>
        <div id="env-results">Running tests...</div>
    </div>
    
    <div class="section">
        <h2>üì° HTTP Headers</h2>
        <div id="header-results">Checking headers...</div>
    </div>
    
    <div class="section">
        <h2>üßÆ Browser Capabilities</h2>
        <div id="capability-results">Testing capabilities...</div>
    </div>
    
    <div class="section">
        <h2>‚öôÔ∏è WASM Threading Test</h2>
        <button onclick="testWasmThreading()">Test WASM Threading</button>
        <div id="wasm-results"></div>
    </div>
    
    <div class="section">
        <h2>üí° Recommendations</h2>
        <div id="recommendations"></div>
    </div>

    <script>
        let testResults = {
            environment: {},
            headers: {},
            capabilities: {},
            wasm: {},
            recommendations: []
        };

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const className = type;
            element.innerHTML += `<div class="${className}">${message}</div>`;
        }

        function logPre(elementId, title, data) {
            const element = document.getElementById(elementId);
            element.innerHTML += `<div class="info">${title}:</div><pre>${JSON.stringify(data, null, 2)}</pre>`;
        }

        // Test 1: Environment Detection
        function testEnvironment() {
            log('env-results', 'üîç Testing Environment...', 'info');
            
            // Basic environment info
            const env = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine
            };
            
            testResults.environment = env;
            logPre('env-results', 'Environment Info', env);
            
            // Browser detection
            const isChrome = /Chrome/.test(navigator.userAgent);
            const isFirefox = /Firefox/.test(navigator.userAgent);
            const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
            const isEdge = /Edg/.test(navigator.userAgent);
            
            log('env-results', `Browser: ${isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isSafari ? 'Safari' : isEdge ? 'Edge' : 'Unknown'}`, 
                isChrome || isFirefox || isEdge ? 'pass' : 'warn');
        }

        // Test 2: HTTP Headers
        async function testHeaders() {
            log('header-results', 'üì° Testing HTTP Headers...', 'info');
            
            try {
                const response = await fetch(location.href);
                const headers = {};
                
                // Check required headers
                const coep = response.headers.get('cross-origin-embedder-policy');
                const coop = response.headers.get('cross-origin-opener-policy');
                const corp = response.headers.get('cross-origin-resource-policy');
                
                headers.coep = coep;
                headers.coop = coop;
                headers.corp = corp;
                headers.crossOriginIsolated = self.crossOriginIsolated;
                
                testResults.headers = headers;
                
                // Log results
                log('header-results', `COEP: ${coep || 'Not set'}`, coep === 'require-corp' ? 'pass' : 'fail');
                log('header-results', `COOP: ${coop || 'Not set'}`, coop === 'same-origin' ? 'pass' : 'fail');
                log('header-results', `Cross-Origin Isolated: ${self.crossOriginIsolated}`, self.crossOriginIsolated ? 'pass' : 'fail');
                
                logPre('header-results', 'All Headers', headers);
                
            } catch (error) {
                log('header-results', `‚ùå Error checking headers: ${error.message}`, 'fail');
            }
        }

        // Test 3: Browser Capabilities
        function testCapabilities() {
            log('capability-results', 'üßÆ Testing Browser Capabilities...', 'info');
            
            const caps = {};
            
            // SharedArrayBuffer
            caps.sharedArrayBuffer = typeof SharedArrayBuffer !== 'undefined';
            log('capability-results', `SharedArrayBuffer: ${caps.sharedArrayBuffer}`, caps.sharedArrayBuffer ? 'pass' : 'fail');
            
            // Atomics
            caps.atomics = typeof Atomics !== 'undefined';
            log('capability-results', `Atomics: ${caps.atomics}`, caps.atomics ? 'pass' : 'fail');
            
            // Web Workers
            caps.webWorkers = typeof Worker !== 'undefined';
            log('capability-results', `Web Workers: ${caps.webWorkers}`, caps.webWorkers ? 'pass' : 'fail');
            
            // WebAssembly
            caps.webAssembly = typeof WebAssembly !== 'undefined';
            log('capability-results', `WebAssembly: ${caps.webAssembly}`, caps.webAssembly ? 'pass' : 'fail');
            
            // WebAssembly Threading
            caps.wasmThreading = typeof WebAssembly.instantiateStreaming === 'function';
            log('capability-results', `WASM Streaming: ${caps.wasmThreading}`, caps.wasmThreading ? 'pass' : 'warn');
            
            // Cross-origin isolation
            caps.crossOriginIsolated = self.crossOriginIsolated;
            log('capability-results', `Cross-Origin Isolated: ${caps.crossOriginIsolated}`, caps.crossOriginIsolated ? 'pass' : 'fail');
            
            // Secure context
            caps.secureContext = self.isSecureContext;
            log('capability-results', `Secure Context: ${caps.secureContext}`, caps.secureContext ? 'pass' : 'warn');
            
            testResults.capabilities = caps;
            logPre('capability-results', 'All Capabilities', caps);
        }

        // Test 4: WASM Threading
        async function testWasmThreading() {
            const resultsEl = document.getElementById('wasm-results');
            resultsEl.innerHTML = '<div class="info">üöÄ Testing WASM Threading...</div>';
            
            try {
                // Import WASM module
                const wasmModule = await import('/wasm/vectorize_wasm.js');
                log('wasm-results', '‚úì WASM module imported', 'pass');
                
                // Initialize WASM
                await wasmModule.default('/wasm/vectorize_wasm_bg.wasm');
                log('wasm-results', '‚úì WASM initialized', 'pass');
                
                // Check for threading functions
                const threadingFunctions = [
                    'is_threading_supported',
                    'init_threading', 
                    'get_thread_count',
                    'set_thread_count'
                ];
                
                const available = {};
                threadingFunctions.forEach(func => {
                    available[func] = typeof wasmModule[func] === 'function';
                    log('wasm-results', `${func}: ${available[func] ? 'Available' : 'Missing'}`, 
                        available[func] ? 'pass' : 'warn');
                });
                
                // Test threading support
                if (wasmModule.is_threading_supported) {
                    const threadingSupported = wasmModule.is_threading_supported();
                    log('wasm-results', `Threading Supported: ${threadingSupported}`, threadingSupported ? 'pass' : 'fail');
                    
                    if (threadingSupported && wasmModule.init_threading) {
                        try {
                            await wasmModule.init_threading();
                            log('wasm-results', '‚úì Threading initialized successfully', 'pass');
                            
                            if (wasmModule.get_thread_count) {
                                const threadCount = wasmModule.get_thread_count();
                                log('wasm-results', `Thread count: ${threadCount}`, 'pass');
                            }
                        } catch (error) {
                            log('wasm-results', `‚ùå Threading init failed: ${error.message}`, 'fail');
                        }
                    }
                } else {
                    log('wasm-results', 'No threading support function found', 'warn');
                }
                
                // Test basic vectorization
                try {
                    const vectorizer = new wasmModule.WasmVectorizer();
                    log('wasm-results', '‚úì WasmVectorizer created', 'pass');
                    
                    // Test with small image
                    const pixels = new Uint8ClampedArray(16); // 2x2 image
                    pixels.fill(255);
                    const imageData = new ImageData(pixels, 2, 2);
                    
                    const svg = vectorizer.vectorize(imageData);
                    log('wasm-results', `‚úì Vectorization successful (${svg.length} chars)`, 'pass');
                    
                    vectorizer.free();
                    log('wasm-results', '‚úì Memory freed', 'pass');
                    
                } catch (error) {
                    log('wasm-results', `‚ùå Vectorization failed: ${error.message}`, 'fail');
                }
                
            } catch (error) {
                log('wasm-results', `‚ùå WASM test failed: ${error.message}`, 'fail');
                console.error('WASM test error:', error);
            }
        }

        // Generate recommendations
        function generateRecommendations() {
            const recs = [];
            
            if (!testResults.headers.crossOriginIsolated) {
                recs.push('üîß Enable cross-origin isolation by setting COEP: require-corp and COOP: same-origin headers');
            }
            
            if (!testResults.capabilities.sharedArrayBuffer) {
                recs.push('üì± SharedArrayBuffer not available - threading will be disabled');
            }
            
            if (!testResults.capabilities.secureContext) {
                recs.push('üîí Use HTTPS or localhost for secure context');
            }
            
            const userAgent = testResults.environment.userAgent || '';
            if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                recs.push('üçé Safari has limited WASM threading support - consider Chrome/Firefox for development');
            }
            
            if (testResults.capabilities.hardwareConcurrency < 2) {
                recs.push('‚ö° Single-core system detected - threading benefits will be minimal');
            }
            
            if (recs.length === 0) {
                recs.push('‚úÖ System appears ready for WASM threading!');
            }
            
            testResults.recommendations = recs;
            
            const recsEl = document.getElementById('recommendations');
            recs.forEach(rec => {
                recsEl.innerHTML += `<div class="info">${rec}</div>`;
            });
        }

        // Run all tests on load
        window.addEventListener('load', async () => {
            testEnvironment();
            await testHeaders();
            testCapabilities();
            generateRecommendations();
        });
    </script>
</body>
</html>