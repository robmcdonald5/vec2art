<!DOCTYPE html>
<html>
<head>
    <title>Safe Threading Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { padding: 10px; margin: 5px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .info { background: #d1ecf1; color: #0c5460; }
        button { margin: 5px; padding: 8px 16px; }
        .progress { width: 100%; height: 20px; background: #f0f0f0; margin: 10px 0; }
        .progress-bar { height: 100%; background: #007acc; transition: width 0.3s; }
    </style>
</head>
<body>
    <h1>🔒 Safe Threading Test</h1>
    <div id="results"></div>
    
    <div>
        <button onclick="testSafeThreading(1)" id="test1">Test 1 Thread</button>
        <button onclick="testSafeThreading(2)" id="test2">Test 2 Threads</button>
        <button onclick="testSafeThreading(4)" id="test4">Test 4 Threads</button>
        <button onclick="testSafeThreading(8)" id="test8">Test 8 Threads</button>
        <button onclick="testSafeThreading(12)" id="test12">Test 12 Threads</button>
        <button onclick="stopTest()" id="stop" style="background: #dc3545; color: white;">STOP TEST</button>
    </div>
    
    <div id="progress-container" style="display: none;">
        <div>Testing progress:</div>
        <div class="progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>

    <script type="module">
        let wasmModule = null;
        let testRunning = false;
        let testController = null;

        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = message;
            document.getElementById('results').appendChild(div);
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function setProgress(percent) {
            document.getElementById('progress-bar').style.width = percent + '%';
            if (percent > 0) {
                document.getElementById('progress-container').style.display = 'block';
            }
        }

        window.stopTest = function() {
            if (testController) {
                testController.abort();
                addResult('🛑 Test stopped by user', 'warning');
            }
            testRunning = false;
            setProgress(0);
            document.getElementById('progress-container').style.display = 'none';
        };

        async function loadWasmSafely() {
            if (wasmModule) return wasmModule;
            
            try {
                addResult('🔄 Loading WASM module safely...', 'info');
                const wasm = await import('/wasm/vectorize_wasm.js');
                await wasm.default();
                wasmModule = wasm;
                addResult('✅ WASM loaded successfully', 'success');
                return wasm;
            } catch (error) {
                addResult(`❌ WASM loading failed: ${error.message}`, 'error');
                throw error;
            }
        }

        window.testSafeThreading = async function(threadCount) {
            if (testRunning) {
                addResult('⚠️ Test already running, please wait or stop current test', 'warning');
                return;
            }

            testRunning = true;
            testController = new AbortController();
            
            try {
                addResult(`🧵 Starting safe test with ${threadCount} threads...`, 'info');
                setProgress(10);

                // Load WASM
                const wasm = await loadWasmSafely();
                if (testController.signal.aborted) return;
                setProgress(20);

                // Check current state
                addResult(`Current threading support: ${wasm.is_threading_supported()}`, 'info');
                addResult(`Current thread count: ${wasm.get_thread_count()}`, 'info');
                setProgress(30);

                // Initialize with controlled thread count and timeout
                addResult(`🔄 Initializing thread pool with ${threadCount} threads (with 10s timeout)...`, 'info');
                
                const initPromise = wasm.initThreadPool(threadCount);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Initialization timeout after 10 seconds')), 10000)
                );

                try {
                    await Promise.race([initPromise, timeoutPromise]);
                    if (testController.signal.aborted) return;
                    setProgress(50);
                    
                    addResult(`✅ Thread pool initialized successfully`, 'success');
                    
                    // Check if threads actually increased
                    const newThreadCount = wasm.get_thread_count();
                    addResult(`Thread count after init: ${newThreadCount}`, 
                        newThreadCount > 1 ? 'success' : 'warning');
                    
                    // Get detailed info
                    const threadingInfo = wasm.get_threading_info();
                    addResult(`Threading info: <pre>${threadingInfo}</pre>`, 'info');
                    setProgress(70);
                    
                    // Test with very small workload
                    addResult('🔄 Testing with minimal workload...', 'info');
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;  // Very small test image
                    canvas.height = 32;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(8, 8, 16, 16);
                    
                    const imageData = ctx.getImageData(0, 0, 32, 32);
                    
                    const vectorizer = new wasm.WasmVectorizer();
                    vectorizer.set_backend('edge');
                    vectorizer.set_detail(0.1); // Very low detail for speed
                    
                    const startTime = performance.now();
                    
                    // Test with timeout
                    const processPromise = Promise.resolve(vectorizer.vectorize(imageData));
                    const processTimeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Processing timeout after 5 seconds')), 5000)
                    );
                    
                    const result = await Promise.race([processPromise, processTimeoutPromise]);
                    const processingTime = performance.now() - startTime;
                    
                    if (testController.signal.aborted) return;
                    setProgress(90);
                    
                    addResult(`✅ Processing completed in ${processingTime.toFixed(2)}ms`, 'success');
                    addResult(`SVG output: ${result.length} characters`, 'info');
                    
                    // Performance assessment
                    if (processingTime < 100) {
                        addResult(`🎉 Performance: Excellent (${threadCount} threads working well)`, 'success');
                    } else if (processingTime < 500) {
                        addResult(`✅ Performance: Good (${threadCount} threads stable)`, 'success');
                    } else if (processingTime < 2000) {
                        addResult(`⚠️ Performance: Acceptable but slow (${threadCount} threads)`, 'warning');
                    } else {
                        addResult(`❌ Performance: Poor (${threadCount} threads may be too many)`, 'error');
                    }
                    
                    setProgress(100);
                    
                } catch (initError) {
                    addResult(`❌ Thread initialization failed: ${initError.message}`, 'error');
                    addResult(`Falling back to single-threaded mode...`, 'warning');
                    
                    // Test fallback
                    wasm.force_single_threaded();
                    const fallbackCount = wasm.get_thread_count();
                    addResult(`Fallback thread count: ${fallbackCount}`, 'info');
                }

            } catch (error) {
                addResult(`❌ Test failed: ${error.message}`, 'error');
                console.error('Threading test error:', error);
                
            } finally {
                testRunning = false;
                setProgress(0);
                setTimeout(() => {
                    document.getElementById('progress-container').style.display = 'none';
                }, 2000);
            }
        };

        // Auto-load WASM on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadWasmSafely().catch(console.error);
        });
    </script>
</body>
</html>