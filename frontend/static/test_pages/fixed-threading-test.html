<!doctype html>
<html>
	<head>
		<title>🔧 Fixed Threading Test</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 20px;
				background: #f8f9fa;
			}
			.container {
				max-width: 900px;
				margin: 0 auto;
				background: white;
				padding: 20px;
				border-radius: 8px;
			}
			.result {
				padding: 10px;
				margin: 5px 0;
				border-radius: 5px;
			}
			.success {
				background: #d4edda;
				color: #155724;
				border-left: 5px solid #28a745;
			}
			.error {
				background: #f8d7da;
				color: #721c24;
				border-left: 5px solid #dc3545;
			}
			.warning {
				background: #fff3cd;
				color: #856404;
				border-left: 5px solid #ffc107;
			}
			.info {
				background: #d1ecf1;
				color: #0c5460;
				border-left: 5px solid #17a2b8;
			}
			button {
				padding: 12px 24px;
				margin: 10px;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-weight: bold;
			}
			.btn-primary {
				background: #007bff;
				color: white;
			}
			.btn-success {
				background: #28a745;
				color: white;
			}
			h1 {
				color: #333;
				text-align: center;
			}
			.status {
				font-size: 1.2em;
				font-weight: bold;
				text-align: center;
				margin: 20px 0;
			}
			pre {
				background: #f8f9fa;
				padding: 10px;
				border-radius: 4px;
				font-size: 0.9em;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>🔧 Fixed Threading State Management Test</h1>
			<div class="status" id="status">Testing fixed threading state management</div>
			<div style="text-align: center; margin: 20px 0">
				<button class="btn-primary" onclick="runFixedTest()" id="testBtn">
					🚀 Test Fixed Threading
				</button>
			</div>
			<div id="results"></div>
		</div>

		<script type="module">
			let testRunning = false;

			function addResult(message, type = 'info', details = null) {
				const div = document.createElement('div');
				div.className = `result ${type}`;
				div.innerHTML = message + (details ? `<pre>${details}</pre>` : '');
				document.getElementById('results').appendChild(div);
				console.log(`[${type.toUpperCase()}]`, message, details || '');
			}

			function updateStatus(message, type = 'info') {
				const statusEl = document.getElementById('status');
				statusEl.textContent = message;
				statusEl.className = `status ${type}`;
			}

			window.runFixedTest = async function () {
				if (testRunning) return;
				testRunning = true;
				document.getElementById('testBtn').disabled = true;
				document.getElementById('results').innerHTML = '';

				try {
					updateStatus('🔄 Testing fixed threading state management...', 'info');

					// STEP 1: Environment Check
					addResult('🔍 STEP 1: Environment Detection', 'info');
					const crossOriginIsolated = window.crossOriginIsolated;
					const sabSupported = typeof SharedArrayBuffer !== 'undefined';
					const cores = navigator.hardwareConcurrency || 1;

					addResult(
						`Cross-Origin Isolation: ${crossOriginIsolated ? '✅ Enabled' : '❌ Disabled'}`,
						crossOriginIsolated ? 'success' : 'error'
					);
					addResult(
						`SharedArrayBuffer: ${sabSupported ? '✅ Available' : '❌ Not available'}`,
						sabSupported ? 'success' : 'error'
					);
					addResult(`Hardware Concurrency: ${cores} cores`, cores > 1 ? 'success' : 'warning');

					if (!crossOriginIsolated || !sabSupported) {
						addResult('❌ Environment not suitable for multithreading', 'error');
						updateStatus('❌ Environment test failed', 'error');
						return;
					}

					// STEP 2: WASM Loading
					addResult('📦 STEP 2: WASM Module Loading', 'info');
					const wasm = await import('/wasm/vectorize_wasm.js');
					await wasm.default();
					addResult('✅ WASM module loaded successfully', 'success');

					// Check for new functions
					const requiredFunctions = [
						'WasmVectorizer',
						'get_thread_count',
						'is_threading_supported',
						'initThreadPool',
						'get_threading_info',
						'confirm_threading_success',
						'mark_threading_failed'
					];
					const missingFunctions = requiredFunctions.filter(
						(fn) => typeof wasm[fn] === 'undefined'
					);

					if (missingFunctions.length > 0) {
						addResult(`❌ Missing functions: ${missingFunctions.join(', ')}`, 'error');
						return;
					}

					addResult(
						`✅ All required functions available (${requiredFunctions.length}/7)`,
						'success'
					);

					// STEP 3: Initial State Check
					addResult('📊 STEP 3: Initial State', 'info');
					const initialThreads = wasm.get_thread_count();
					const initialSupported = wasm.is_threading_supported();
					const initialInfo = wasm.get_threading_info();
					addResult(
						`Initial state:`,
						'info',
						`Threads: ${initialThreads}\\nSupported: ${initialSupported}\\n\\n${initialInfo}`
					);

					// STEP 4: Fixed Threading Initialization
					addResult(
						'🔧 STEP 4: Fixed Threading Initialization with Proper State Management',
						'info'
					);
					updateStatus('🔄 Initializing with fixed state management...', 'info');

					try {
						// Call initThreadPool with explicit promise handling
						const targetThreads = Math.min(4, cores);
						addResult(
							`🔄 Calling initThreadPool(${targetThreads}) with proper error handling...`,
							'info'
						);

						const promise = wasm.initThreadPool(targetThreads);
						addResult(`📝 initThreadPool returned promise: ${typeof promise}`, 'info');

						// Await the promise with proper error handling
						try {
							const result = await promise;
							addResult(
								`✅ Threading promise resolved successfully!`,
								'success',
								`Result: ${result}`
							);

							// Call our new confirm function
							wasm.confirm_threading_success();
							addResult('✅ Called confirm_threading_success()', 'success');
						} catch (promiseError) {
							addResult(
								`❌ Threading promise REJECTED:`,
								'error',
								`Error: ${promiseError.name}: ${promiseError.message}\\nStack: ${promiseError.stack}`
							);

							// Call our new failure function
							wasm.mark_threading_failed();
							addResult('❌ Called mark_threading_failed()', 'error');
						}

						// STEP 5: Final State Check
						addResult('📊 STEP 5: Final State Check', 'info');
						const finalThreads = wasm.get_thread_count();
						const finalSupported = wasm.is_threading_supported();
						const finalInfo = wasm.get_threading_info();

						addResult(
							`Final state after proper state management:`,
							'info',
							`Threads: ${finalThreads}\\nSupported: ${finalSupported}\\n\\n${finalInfo}`
						);

						// STEP 6: Functionality Test
						if (finalSupported && finalThreads > 1) {
							addResult('⚡ STEP 6: Multithreading Functionality Test', 'info');

							// Create small test image
							const canvas = document.createElement('canvas');
							canvas.width = 32;
							canvas.height = 32;
							const ctx = canvas.getContext('2d');
							ctx.fillStyle = '#000';
							ctx.fillRect(8, 8, 16, 16);

							const imageData = ctx.getImageData(0, 0, 32, 32);
							const vectorizer = new wasm.WasmVectorizer();

							const startTime = performance.now();
							const result = vectorizer.vectorize(imageData);
							const processingTime = performance.now() - startTime;

							addResult(
								`✅ Multithreaded vectorization successful in ${processingTime.toFixed(2)}ms`,
								'success'
							);
							addResult(`📊 SVG output: ${result.length} characters`, 'info');

							updateStatus(
								`🎉 SUCCESS! Fixed threading working with ${finalThreads} threads!`,
								'success'
							);
						} else {
							addResult(
								`⚠️ Threading failed - using fallback mode (${finalThreads} thread)`,
								'warning'
							);
							updateStatus('⚠️ Threading failed - fallback mode active', 'warning');
						}
					} catch (initError) {
						addResult(`💥 Threading initialization error: ${initError.message}`, 'error');
						updateStatus('❌ Threading initialization failed', 'error');
					}
				} catch (error) {
					addResult(`💥 Critical error: ${error.message}`, 'error');
					updateStatus('❌ Test failed', 'error');
					console.error('Full test error:', error);
				} finally {
					testRunning = false;
					document.getElementById('testBtn').disabled = false;
				}
			};

			// Auto-run test
			document.addEventListener('DOMContentLoaded', () => {
				setTimeout(() => {
					addResult('🔧 Testing fixed threading state management system', 'info');
					addResult(
						'📝 This test uses confirm_threading_success() and mark_threading_failed()',
						'info'
					);
				}, 500);
			});
		</script>
	</body>
</html>
