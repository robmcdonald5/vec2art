<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>WASM Threading Comprehensive Test</title>
		<style>
			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				margin: 20px;
				background: #f5f5f5;
			}
			.container {
				max-width: 1200px;
				margin: 0 auto;
				background: white;
				padding: 20px;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}
			h1 {
				color: #333;
				border-bottom: 2px solid #007acc;
				padding-bottom: 10px;
			}
			.test-section {
				margin: 20px 0;
				padding: 15px;
				border: 1px solid #ddd;
				border-radius: 5px;
				background: #fafafa;
			}
			.test-result {
				margin: 10px 0;
				padding: 8px 12px;
				border-radius: 4px;
				font-weight: bold;
			}
			.success {
				background: #d4edda;
				color: #155724;
				border: 1px solid #c3e6cb;
			}
			.error {
				background: #f8d7da;
				color: #721c24;
				border: 1px solid #f5c6cb;
			}
			.warning {
				background: #fff3cd;
				color: #856404;
				border: 1px solid #ffeaa7;
			}
			.info {
				background: #d1ecf1;
				color: #0c5460;
				border: 1px solid #bee5eb;
			}

			button {
				background: #007acc;
				color: white;
				border: none;
				padding: 10px 20px;
				border-radius: 4px;
				cursor: pointer;
				margin: 5px;
			}
			button:hover {
				background: #005999;
			}
			button:disabled {
				background: #ccc;
				cursor: not-allowed;
			}

			.code {
				background: #f4f4f4;
				padding: 10px;
				border-radius: 4px;
				font-family: 'Courier New', monospace;
				margin: 10px 0;
			}

			.progress {
				width: 100%;
				height: 20px;
				background: #f0f0f0;
				border-radius: 10px;
				overflow: hidden;
				margin: 10px 0;
			}
			.progress-bar {
				height: 100%;
				background: #007acc;
				transition: width 0.3s ease;
			}

			.details {
				display: none;
				margin-top: 10px;
				font-size: 0.9em;
				color: #666;
			}
			.details.show {
				display: block;
			}

			.toggle {
				cursor: pointer;
				color: #007acc;
				text-decoration: underline;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>üßµ WASM Threading Comprehensive Test Suite</h1>

			<div class="test-section">
				<h2>üîç Environment Detection</h2>
				<div id="environment-results"></div>
				<button onclick="runEnvironmentTests()" id="env-btn">Run Environment Tests</button>
			</div>

			<div class="test-section">
				<h2>üì¶ WASM Module Loading</h2>
				<div id="loading-results"></div>
				<button onclick="runWasmLoadingTests()" id="load-btn">Test WASM Loading</button>
			</div>

			<div class="test-section">
				<h2>üßµ Threading Capability</h2>
				<div id="threading-results"></div>
				<button onclick="runThreadingTests()" id="thread-btn" disabled>Test Threading</button>
			</div>

			<div class="test-section">
				<h2>‚ö° Performance Comparison</h2>
				<div id="performance-results"></div>
				<button onclick="runPerformanceTests()" id="perf-btn" disabled>
					Run Performance Tests
				</button>
			</div>

			<div class="test-section">
				<h2>üîß Progressive Enhancement</h2>
				<div id="enhancement-results"></div>
				<button onclick="runProgressiveTests()" id="prog-btn" disabled>
					Test Progressive Enhancement
				</button>
			</div>

			<div class="test-section">
				<h2>üìä Debug Information</h2>
				<div id="debug-info"></div>
				<button onclick="showDebugInfo()">Show Debug Info</button>
			</div>
		</div>

		<script type="module">
			let wasmModule = null;
			let testResults = {
				environment: {},
				loading: {},
				threading: {},
				performance: {},
				enhancement: {}
			};

			// Utility functions
			function addResult(containerId, message, type = 'info') {
				const container = document.getElementById(containerId);
				const div = document.createElement('div');
				div.className = `test-result ${type}`;
				div.innerHTML = message;
				container.appendChild(div);
			}

			function clearResults(containerId) {
				document.getElementById(containerId).innerHTML = '';
			}

			// Environment Detection Tests
			window.runEnvironmentTests = function () {
				clearResults('environment-results');

				// Check browser support
				const crossOriginIsolated = window.crossOriginIsolated;
				addResult(
					'environment-results',
					`Cross-Origin Isolation: ${crossOriginIsolated ? '‚úÖ Enabled' : '‚ùå Not enabled'}`,
					crossOriginIsolated ? 'success' : 'error'
				);

				// Check SharedArrayBuffer
				const sabSupported = typeof SharedArrayBuffer !== 'undefined';
				addResult(
					'environment-results',
					`SharedArrayBuffer: ${sabSupported ? '‚úÖ Available' : '‚ùå Not available'}`,
					sabSupported ? 'success' : 'error'
				);

				// Check hardware concurrency
				const cores = navigator.hardwareConcurrency || 1;
				addResult(
					'environment-results',
					`Hardware Concurrency: ${cores} cores`,
					cores > 1 ? 'success' : 'warning'
				);

				// Check headers via fetch
				fetch(window.location.href)
					.then((response) => {
						const coep = response.headers.get('cross-origin-embedder-policy');
						const coop = response.headers.get('cross-origin-opener-policy');

						addResult(
							'environment-results',
							`COEP Header: ${coep || 'Not set'}`,
							coep ? 'success' : 'warning'
						);

						addResult(
							'environment-results',
							`COOP Header: ${coop || 'Not set'}`,
							coop ? 'success' : 'warning'
						);
					})
					.catch((err) => {
						addResult('environment-results', `Header check failed: ${err.message}`, 'error');
					});

				testResults.environment = {
					crossOriginIsolated,
					sabSupported,
					hardwareConcurrency: cores
				};
			};

			// WASM Loading Tests
			window.runWasmLoadingTests = async function () {
				clearResults('loading-results');
				document.getElementById('load-btn').disabled = true;

				try {
					addResult('loading-results', 'üîÑ Loading WASM module...', 'info');

					const startTime = performance.now();

					// Try to import WASM module
					const wasmImport = await import('/wasm/vectorize_wasm.js');
					const loadTime = performance.now() - startTime;

					addResult('loading-results', `‚úÖ WASM JS loaded in ${loadTime.toFixed(2)}ms`, 'success');

					// Initialize WASM
					const initStartTime = performance.now();
					await wasmImport.default();
					const initTime = performance.now() - initStartTime;

					addResult(
						'loading-results',
						`‚úÖ WASM initialized in ${initTime.toFixed(2)}ms`,
						'success'
					);

					wasmModule = wasmImport;

					// Check available functions
					const functions = [
						'WasmVectorizer',
						'get_thread_count',
						'is_threading_supported',
						'get_threading_info',
						'initThreadPool'
					];

					let availableFunctions = 0;
					functions.forEach((funcName) => {
						if (typeof wasmImport[funcName] !== 'undefined') {
							availableFunctions++;
							addResult('loading-results', `‚úÖ Function available: ${funcName}`, 'success');
						} else {
							addResult('loading-results', `‚ùå Function missing: ${funcName}`, 'error');
						}
					});

					addResult(
						'loading-results',
						`üìä Available functions: ${availableFunctions}/${functions.length}`,
						availableFunctions === functions.length ? 'success' : 'warning'
					);

					// Enable next tests
					document.getElementById('thread-btn').disabled = false;
					document.getElementById('perf-btn').disabled = false;
					document.getElementById('prog-btn').disabled = false;

					testResults.loading = {
						success: true,
						loadTime,
						initTime,
						availableFunctions
					};
				} catch (error) {
					addResult('loading-results', `‚ùå WASM loading failed: ${error.message}`, 'error');
					testResults.loading = { success: false, error: error.message };
				} finally {
					document.getElementById('load-btn').disabled = false;
				}
			};

			// Threading Tests
			window.runThreadingTests = async function () {
				if (!wasmModule) {
					addResult('threading-results', '‚ùå WASM module not loaded', 'error');
					return;
				}

				clearResults('threading-results');

				try {
					// Check threading support
					const isSupported = wasmModule.is_threading_supported();
					addResult(
						'threading-results',
						`Threading Support: ${isSupported ? '‚úÖ Supported' : '‚ùå Not supported'}`,
						isSupported ? 'success' : 'warning'
					);

					// Get thread count
					const threadCount = wasmModule.get_thread_count();
					addResult(
						'threading-results',
						`Thread Count: ${threadCount}`,
						threadCount > 1 ? 'success' : 'info'
					);

					// Get threading info
					const threadingInfo = wasmModule.get_threading_info();
					addResult(
						'threading-results',
						`Threading Info: <div class="code">${threadingInfo}</div>`,
						'info'
					);

					// Try to initialize thread pool if supported
					if (typeof wasmModule.initThreadPool === 'function') {
						try {
							addResult('threading-results', 'üîÑ Initializing thread pool...', 'info');

							const initResult = await wasmModule.initThreadPool();
							addResult(
								'threading-results',
								`‚úÖ Thread pool initialized: ${initResult}`,
								'success'
							);

							// Check if thread count changed
							const newThreadCount = wasmModule.get_thread_count();
							if (newThreadCount !== threadCount) {
								addResult(
									'threading-results',
									`üìà Thread count updated: ${threadCount} ‚Üí ${newThreadCount}`,
									'success'
								);
							}
						} catch (initError) {
							addResult(
								'threading-results',
								`‚ö†Ô∏è Thread pool init error: ${initError.message}`,
								'warning'
							);
						}
					} else {
						addResult('threading-results', '‚ùå initThreadPool function not available', 'error');
					}

					testResults.threading = {
						supported: isSupported,
						threadCount,
						info: threadingInfo
					};
				} catch (error) {
					addResult('threading-results', `‚ùå Threading test failed: ${error.message}`, 'error');
					testResults.threading = { error: error.message };
				}
			};

			// Performance Tests
			window.runPerformanceTests = async function () {
				if (!wasmModule) {
					addResult('performance-results', '‚ùå WASM module not loaded', 'error');
					return;
				}

				clearResults('performance-results');
				addResult('performance-results', 'üîÑ Running performance tests...', 'info');

				// Create test image data
				const canvas = document.createElement('canvas');
				canvas.width = 200;
				canvas.height = 200;
				const ctx = canvas.getContext('2d');

				// Draw a simple test pattern
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(0, 0, 200, 200);
				ctx.fillStyle = '#000000';
				ctx.fillRect(50, 50, 100, 100);
				ctx.strokeStyle = '#666666';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.arc(100, 100, 30, 0, Math.PI * 2);
				ctx.stroke();

				const imageData = ctx.getImageData(0, 0, 200, 200);

				try {
					// Test single-threaded performance
					const vectorizer = new wasmModule.WasmVectorizer();
					vectorizer.set_backend('edge');
					vectorizer.set_detail(0.3);

					const singleThreadStart = performance.now();
					const result = vectorizer.vectorize(imageData);
					const singleThreadTime = performance.now() - singleThreadStart;

					addResult(
						'performance-results',
						`‚úÖ Single-thread processing: ${singleThreadTime.toFixed(2)}ms`,
						'success'
					);

					addResult(
						'performance-results',
						`üìä SVG output size: ${result.length} characters`,
						'info'
					);

					// If threading is supported, compare performance
					if (wasmModule.is_threading_supported()) {
						addResult('performance-results', 'üîÑ Testing multi-threaded performance...', 'info');

						// Force multi-threaded mode and test again
						const multiVectorizer = new wasmModule.WasmVectorizer();
						multiVectorizer.set_backend('edge');
						multiVectorizer.set_detail(0.3);
						multiVectorizer.set_thread_count(navigator.hardwareConcurrency || 2);

						const multiThreadStart = performance.now();
						const multiResult = multiVectorizer.vectorize(imageData);
						const multiThreadTime = performance.now() - multiThreadStart;

						addResult(
							'performance-results',
							`‚úÖ Multi-thread processing: ${multiThreadTime.toFixed(2)}ms`,
							'success'
						);

						const speedup = (singleThreadTime / multiThreadTime - 1) * 100;
						const speedupClass = speedup > 0 ? 'success' : 'warning';
						addResult(
							'performance-results',
							`üìà Performance comparison: ${speedup > 0 ? '+' : ''}${speedup.toFixed(1)}% ${speedup > 0 ? 'faster' : 'slower'}`,
							speedupClass
						);
					} else {
						addResult(
							'performance-results',
							'‚ÑπÔ∏è Multi-threading not supported, skipping comparison',
							'info'
						);
					}

					testResults.performance = {
						singleThreadTime,
						resultSize: result.length
					};
				} catch (error) {
					addResult('performance-results', `‚ùå Performance test failed: ${error.message}`, 'error');
					testResults.performance = { error: error.message };
				}
			};

			// Progressive Enhancement Tests
			window.runProgressiveTests = async function () {
				if (!wasmModule) {
					addResult('enhancement-results', '‚ùå WASM module not loaded', 'error');
					return;
				}

				clearResults('enhancement-results');

				try {
					addResult('enhancement-results', 'üîÑ Testing progressive enhancement...', 'info');

					// Test automatic fallback detection
					const supportsBefore = wasmModule.is_threading_supported();
					addResult(
						'enhancement-results',
						`Initial threading support: ${supportsBefore ? 'Enabled' : 'Disabled'}`,
						'info'
					);

					// Test forced single-threaded mode
					wasmModule.force_single_threaded();
					const supportsAfter = wasmModule.is_threading_supported();

					addResult(
						'enhancement-results',
						`After force_single_threaded(): ${supportsAfter ? 'Still enabled' : 'Disabled'}`,
						!supportsAfter ? 'success' : 'warning'
					);

					// Test thread count changes
					const threadCountAfter = wasmModule.get_thread_count();
					addResult(
						'enhancement-results',
						`Thread count after fallback: ${threadCountAfter}`,
						threadCountAfter === 1 ? 'success' : 'warning'
					);

					// Test that functionality still works in fallback mode
					const vectorizer = new wasmModule.WasmVectorizer();
					const canvas = document.createElement('canvas');
					canvas.width = 50;
					canvas.height = 50;
					const ctx = canvas.getContext('2d');
					ctx.fillStyle = '#000000';
					ctx.fillRect(10, 10, 30, 30);

					const testImageData = ctx.getImageData(0, 0, 50, 50);
					const fallbackResult = vectorizer.vectorize(testImageData);

					addResult(
						'enhancement-results',
						`‚úÖ Fallback processing works: ${fallbackResult.length} chars`,
						'success'
					);

					testResults.enhancement = {
						supportsBefore,
						supportsAfter,
						threadCountAfter,
						fallbackWorks: fallbackResult.length > 0
					};
				} catch (error) {
					addResult(
						'enhancement-results',
						`‚ùå Progressive enhancement test failed: ${error.message}`,
						'error'
					);
					testResults.enhancement = { error: error.message };
				}
			};

			// Debug Information
			window.showDebugInfo = function () {
				const debugContainer = document.getElementById('debug-info');
				debugContainer.innerHTML = `
                <div class="code">
                    <h3>üîß Complete Debug Information</h3>
                    <h4>Browser Environment:</h4>
                    <pre>User Agent: ${navigator.userAgent}
Hardware Concurrency: ${navigator.hardwareConcurrency || 'Unknown'}
Cross-Origin Isolated: ${window.crossOriginIsolated || false}
SharedArrayBuffer Available: ${typeof SharedArrayBuffer !== 'undefined'}</pre>
                    
                    <h4>WASM Module Status:</h4>
                    <pre>Module Loaded: ${wasmModule ? 'Yes' : 'No'}
${
	wasmModule
		? 'Available Functions: ' +
			Object.keys(wasmModule)
				.filter((k) => typeof wasmModule[k] === 'function')
				.join(', ')
		: 'No functions available'
}</pre>
                    
                    <h4>Test Results Summary:</h4>
                    <pre>${JSON.stringify(testResults, null, 2)}</pre>
                    
                    <h4>Threading Information (if available):</h4>
                    <pre>${wasmModule && typeof wasmModule.get_threading_info === 'function' ? wasmModule.get_threading_info() : 'Threading info not available'}</pre>
                </div>
            `;
			};

			// Auto-run environment tests on page load
			document.addEventListener('DOMContentLoaded', () => {
				runEnvironmentTests();
			});
		</script>
	</body>
</html>
