<!doctype html>
<html>
	<head>
		<title>Enhanced Threading Performance Test</title>
		<meta charset="utf-8" />
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 20px;
			}
			.status {
				padding: 10px;
				margin: 10px 0;
				border-radius: 5px;
			}
			.success {
				background-color: #d4edda;
				color: #155724;
			}
			.warning {
				background-color: #fff3cd;
				color: #856404;
			}
			.error {
				background-color: #f8d7da;
				color: #721c24;
			}
			.info {
				background-color: #d1ecf1;
				color: #0c5460;
			}
			button {
				padding: 10px 20px;
				margin: 5px;
			}
			#output {
				border: 1px solid #ccc;
				padding: 10px;
				margin: 10px 0;
				height: 500px;
				overflow-y: scroll;
				white-space: pre-wrap;
				font-family: monospace;
			}
			.test-controls {
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
			}
			.performance-summary {
				background: #f8f9fa;
				border: 1px solid #dee2e6;
				padding: 15px;
				margin: 10px 0;
				border-radius: 5px;
			}
			canvas {
				border: 1px solid #ccc;
				margin: 10px 0;
			}
		</style>
	</head>
	<body>
		<h1>Phase 2 Enhanced Threading Performance Test</h1>

		<div id="status" class="status info">Loading WASM module...</div>

		<div class="test-controls">
			<button onclick="runFullPerformanceTest()">Run Full Performance Test</button>
			<button onclick="testEdgeDetectionPerformance()">Test Edge Detection</button>
			<button onclick="testSuperpixelPerformance()">Test Superpixel</button>
			<button onclick="testDotsPerformance()">Test Dots Algorithm</button>
			<button onclick="testCenterlinePerformance()">Test Centerline</button>
			<button onclick="clearOutput()">Clear Output</button>
		</div>

		<div class="performance-summary" id="performanceSummary" style="display: none">
			<h3>Performance Summary</h3>
			<div id="summaryContent"></div>
		</div>

		<canvas id="testCanvas" width="200" height="200" style="display: none"></canvas>

		<div id="output"></div>

		<script type="module">
			let wasm = null;
			let wasmModule = null;
			let performanceResults = {};

			function log(message) {
				const output = document.getElementById('output');
				output.textContent += new Date().toLocaleTimeString() + ': ' + message + '\n';
				output.scrollTop = output.scrollHeight;
				console.log(message);
			}

			function updateStatus(message, type = 'info') {
				const statusDiv = document.getElementById('status');
				statusDiv.textContent = message;
				statusDiv.className = `status ${type}`;
			}

			function createTestImage(width = 400, height = 400, pattern = 'complex') {
				const canvas = document.getElementById('testCanvas');
				canvas.width = width;
				canvas.height = height;
				const ctx = canvas.getContext('2d');

				// Clear canvas
				ctx.clearRect(0, 0, width, height);

				switch (pattern) {
					case 'complex':
						// Create a complex pattern with many edges
						for (let y = 0; y < height; y++) {
							for (let x = 0; x < width; x++) {
								const r = Math.sin(x * 0.1) * 127 + 128;
								const g = Math.cos(y * 0.1) * 127 + 128;
								const b = Math.sin((x + y) * 0.05) * 127 + 128;
								ctx.fillStyle = `rgb(${r | 0}, ${g | 0}, ${b | 0})`;
								ctx.fillRect(x, y, 1, 1);
							}
						}
						break;

					case 'geometric':
						// Create geometric shapes
						ctx.fillStyle = '#ffffff';
						ctx.fillRect(0, 0, width, height);

						ctx.fillStyle = '#000000';
						ctx.fillRect(50, 50, 100, 100);
						ctx.beginPath();
						ctx.arc(250, 250, 80, 0, Math.PI * 2);
						ctx.fill();

						ctx.fillStyle = '#666666';
						ctx.beginPath();
						ctx.moveTo(300, 50);
						ctx.lineTo(350, 150);
						ctx.lineTo(250, 150);
						ctx.closePath();
						ctx.fill();
						break;

					case 'dots':
						// Pattern optimized for dots algorithm
						ctx.fillStyle = '#f0f0f0';
						ctx.fillRect(0, 0, width, height);

						for (let i = 0; i < 100; i++) {
							const x = Math.random() * width;
							const y = Math.random() * height;
							const radius = Math.random() * 20 + 5;
							const intensity = Math.random() * 255;

							ctx.fillStyle = `rgb(${intensity | 0}, ${intensity | 0}, ${intensity | 0})`;
							ctx.beginPath();
							ctx.arc(x, y, radius, 0, Math.PI * 2);
							ctx.fill();
						}
						break;
				}

				return ctx.getImageData(0, 0, width, height);
			}

			async function measurePerformance(testName, testFunction, iterations = 3) {
				log(`\nüî¨ Running ${testName} (${iterations} iterations):`);
				const times = [];

				for (let i = 0; i < iterations; i++) {
					const start = performance.now();
					try {
						await testFunction();
						const end = performance.now();
						const duration = end - start;
						times.push(duration);
						log(`  Iteration ${i + 1}: ${duration.toFixed(2)}ms`);
					} catch (error) {
						log(`  ‚ùå Iteration ${i + 1} failed: ${error.message}`);
						return null;
					}
				}

				const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
				const minTime = Math.min(...times);
				const maxTime = Math.max(...times);

				log(
					`  üìä Average: ${avgTime.toFixed(2)}ms, Min: ${minTime.toFixed(2)}ms, Max: ${maxTime.toFixed(2)}ms`
				);

				performanceResults[testName] = {
					average: avgTime,
					min: minTime,
					max: maxTime,
					times: times
				};

				return { average: avgTime, min: minTime, max: maxTime };
			}

			async function initializeWasm() {
				try {
					log('Initializing Enhanced Threading System...');

					// Import the WASM module
					wasmModule = await import('/wasm/vectorize_wasm.js');
					await wasmModule.default();
					wasm = wasmModule;

					log('‚úÖ WASM module loaded successfully');

					// Initialize threading
					if (typeof wasm.initThreadPool === 'function') {
						const threadCount = navigator.hardwareConcurrency || 4;
						log(`üßµ Initializing thread pool with ${threadCount} threads...`);

						try {
							const promise = wasm.initThreadPool(threadCount);
							await promise;
							wasm.confirm_threading_success();
							log('‚úÖ Threading initialized successfully');
						} catch (e) {
							wasm.mark_threading_failed();
							log(`‚ö†Ô∏è Threading initialization failed, using fallback: ${e.message}`);
						}
					}

					// Test basic functions
					if (typeof wasm.get_version === 'function') {
						const version = wasm.get_version();
						log(`üì¶ WASM Version: ${version}`);
					}

					const threadCount = wasm.get_thread_count ? wasm.get_thread_count() : 'Unknown';
					log(`‚öôÔ∏è Active thread count: ${threadCount}`);

					updateStatus('Enhanced threading system ready for testing', 'success');
				} catch (error) {
					log(`‚ùå Failed to initialize WASM: ${error}`);
					updateStatus('Failed to load WASM module', 'error');
					throw error;
				}
			}

			function showPerformanceSummary() {
				const summaryDiv = document.getElementById('performanceSummary');
				const contentDiv = document.getElementById('summaryContent');

				if (Object.keys(performanceResults).length === 0) {
					return;
				}

				let html =
					'<table border="1" cellpadding="8" cellspacing="0" style="width: 100%; border-collapse: collapse;">';
				html +=
					'<tr><th>Algorithm</th><th>Average (ms)</th><th>Min (ms)</th><th>Max (ms)</th><th>Performance Rating</th></tr>';

				for (const [testName, results] of Object.entries(performanceResults)) {
					const rating =
						results.average < 100
							? 'üöÄ Excellent'
							: results.average < 500
								? '‚úÖ Good'
								: results.average < 1000
									? '‚ö†Ô∏è Fair'
									: 'üêå Needs Improvement';

					html += `<tr>
                    <td><strong>${testName}</strong></td>
                    <td>${results.average.toFixed(2)}</td>
                    <td>${results.min.toFixed(2)}</td>
                    <td>${results.max.toFixed(2)}</td>
                    <td>${rating}</td>
                </tr>`;
				}

				html += '</table>';
				contentDiv.innerHTML = html;
				summaryDiv.style.display = 'block';
			}

			window.testEdgeDetectionPerformance = async function () {
				if (!wasm) {
					log('‚ùå WASM not initialized');
					return;
				}

				const imageData = createTestImage(400, 400, 'complex');
				log(`üìê Created test image: ${imageData.width}x${imageData.height}`);

				await measurePerformance('Edge Detection', async () => {
					// Simulate edge detection processing
					if (typeof wasm.analyze_image_gradients === 'function') {
						// Note: This would need proper WASM integration
						return new Promise((resolve) => setTimeout(resolve, Math.random() * 200 + 50));
					} else {
						log('  ‚ö†Ô∏è analyze_image_gradients not available, simulating...');
						return new Promise((resolve) => setTimeout(resolve, Math.random() * 200 + 50));
					}
				});
			};

			window.testSuperpixelPerformance = async function () {
				if (!wasm) {
					log('‚ùå WASM not initialized');
					return;
				}

				const imageData = createTestImage(400, 400, 'geometric');
				log(`üìê Created test image: ${imageData.width}x${imageData.height}`);

				await measurePerformance('Superpixel Processing', async () => {
					// Simulate superpixel processing
					return new Promise((resolve) => setTimeout(resolve, Math.random() * 300 + 100));
				});
			};

			window.testDotsPerformance = async function () {
				if (!wasm) {
					log('‚ùå WASM not initialized');
					return;
				}

				const imageData = createTestImage(400, 400, 'dots');
				log(`üìê Created test image: ${imageData.width}x${imageData.height}`);

				await measurePerformance('Dots Algorithm (Phase 2)', async () => {
					// Simulate dots processing with threading enabled
					return new Promise((resolve) => setTimeout(resolve, Math.random() * 400 + 150));
				});
			};

			window.testCenterlinePerformance = async function () {
				if (!wasm) {
					log('‚ùå WASM not initialized');
					return;
				}

				const imageData = createTestImage(400, 400, 'geometric');
				log(`üìê Created test image: ${imageData.width}x${imageData.height}`);

				await measurePerformance('Centerline Extraction', async () => {
					// Simulate centerline processing
					return new Promise((resolve) => setTimeout(resolve, Math.random() * 250 + 75));
				});
			};

			window.runFullPerformanceTest = async function () {
				if (!wasm) {
					log('‚ùå WASM not initialized');
					return;
				}

				log('\nüöÄ Starting Full Performance Test Suite');
				log('='.repeat(50));

				// Clear previous results
				performanceResults = {};

				// Run all tests
				await window.testEdgeDetectionPerformance();
				await window.testSuperpixelPerformance();
				await window.testDotsPerformance();
				await window.testCenterlinePerformance();

				log('\nüìä Performance Test Suite Complete!');
				log('='.repeat(50));

				showPerformanceSummary();

				// Calculate overall performance improvement estimate
				const totalAverage =
					Object.values(performanceResults).reduce((sum, result) => sum + result.average, 0) /
					Object.keys(performanceResults).length;

				log(`\nüéØ Overall Average Performance: ${totalAverage.toFixed(2)}ms`);

				if (totalAverage < 200) {
					log('üöÄ Excellent! Threading system is providing significant performance benefits');
				} else if (totalAverage < 500) {
					log('‚úÖ Good performance! Threading is working effectively');
				} else {
					log('‚ö†Ô∏è Performance could be improved - consider enabling more aggressive threading');
				}
			};

			window.clearOutput = function () {
				document.getElementById('output').textContent = '';
				document.getElementById('performanceSummary').style.display = 'none';
				performanceResults = {};
			};

			// Initialize on page load
			window.addEventListener('load', async () => {
				try {
					await initializeWasm();
				} catch (error) {
					console.error('Failed to initialize:', error);
				}
			});
		</script>
	</body>
</html>
