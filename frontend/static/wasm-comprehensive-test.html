<!DOCTYPE html>
<html>
<head>
    <title>üî¨ Comprehensive WASM Test Suite</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #e0e0e0; 
            max-width: 1200px;
            margin: 0 auto;
        }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            background: #2a2a2a; 
            border-radius: 8px;
        }
        .pass { color: #4caf50; }
        .fail { color: #f44336; }
        .warn { color: #ff9800; }
        .info { color: #2196f3; }
        pre { 
            background: #333; 
            padding: 10px; 
            border-radius: 4px; 
            overflow-x: auto;
            max-height: 200px;
        }
        button {
            background: #4fc3f7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #29b6f6; }
        button:disabled { 
            background: #666; 
            cursor: not-allowed; 
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .grid { grid-template-columns: 1fr; }
        }
        .status-line {
            margin: 5px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .compact { font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>üî¨ Comprehensive WASM Test Suite</h1>
    <p class="info">This unified test page consolidates all WASM testing capabilities.</p>
    
    <div class="grid">
        <div class="section">
            <h2>üîç Environment Detection</h2>
            <div id="env-results">Loading...</div>
        </div>
        
        <div class="section">
            <h2>üì° HTTP Headers & CORS</h2>
            <div id="header-results">Checking...</div>
        </div>
    </div>
    
    <div class="grid">
        <div class="section">
            <h2>üßÆ Browser Capabilities</h2>
            <div id="capability-results">Testing...</div>
        </div>
        
        <div class="section">
            <h2>‚öôÔ∏è WASM Module Loading</h2>
            <button onclick="testWasmLoading()">Test WASM Loading</button>
            <div id="wasm-loading-results"></div>
        </div>
    </div>
    
    <div class="section">
        <h2>üßµ Threading & Performance</h2>
        <button onclick="testWasmThreading()" id="threading-btn">Test Threading</button>
        <button onclick="testProcessing()" id="processing-btn">Test Processing</button>
        <div id="threading-results"></div>
    </div>
    
    <div class="section">
        <h2>üéØ Vectorization Tests</h2>
        <button onclick="testVectorization()">Test Basic Vectorization</button>
        <button onclick="testAllBackends()">Test All Backends</button>
        <div id="vectorization-results"></div>
    </div>
    
    <div class="section">
        <h2>üí° System Analysis & Recommendations</h2>
        <div id="recommendations"></div>
    </div>

    <script>
        let testResults = {
            environment: {},
            headers: {},
            capabilities: {},
            wasm: {},
            vectorization: {},
            recommendations: []
        };
        
        let wasmModule = null;

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const className = type;
            element.innerHTML += `<div class="status-line ${className}">${message}</div>`;
        }

        function logPre(elementId, title, data) {
            const element = document.getElementById(elementId);
            element.innerHTML += `<div class="info">${title}:</div><pre class="compact">${JSON.stringify(data, null, 2)}</pre>`;
        }

        function clearResults(elementId) {
            document.getElementById(elementId).innerHTML = '';
        }

        // Test 1: Environment Detection
        function testEnvironment() {
            log('env-results', 'üîç Analyzing Environment...', 'info');
            
            const env = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                deviceMemory: navigator.deviceMemory || 'Unknown'
            };
            
            testResults.environment = env;
            
            // Browser detection
            const isChrome = /Chrome/.test(navigator.userAgent);
            const isFirefox = /Firefox/.test(navigator.userAgent);
            const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
            const isEdge = /Edg/.test(navigator.userAgent);
            
            const browser = isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isSafari ? 'Safari' : isEdge ? 'Edge' : 'Unknown';
            log('env-results', `Browser: ${browser}`, isChrome || isFirefox || isEdge ? 'pass' : 'warn');
            log('env-results', `Platform: ${env.platform}`, 'info');
            log('env-results', `CPU Cores: ${env.hardwareConcurrency}`, env.hardwareConcurrency >= 2 ? 'pass' : 'warn');
            
            if (env.deviceMemory) {
                log('env-results', `Device Memory: ${env.deviceMemory}GB`, env.deviceMemory >= 4 ? 'pass' : 'warn');
            }
        }

        // Test 2: HTTP Headers
        async function testHeaders() {
            log('header-results', 'üì° Checking HTTP Headers...', 'info');
            
            try {
                const response = await fetch(location.href);
                const headers = {};
                
                const coep = response.headers.get('cross-origin-embedder-policy');
                const coop = response.headers.get('cross-origin-opener-policy');
                const corp = response.headers.get('cross-origin-resource-policy');
                
                headers.coep = coep;
                headers.coop = coop;
                headers.corp = corp;
                headers.crossOriginIsolated = self.crossOriginIsolated;
                
                testResults.headers = headers;
                
                log('header-results', `COEP: ${coep || 'Not set'}`, coep === 'require-corp' ? 'pass' : 'fail');
                log('header-results', `COOP: ${coop || 'Not set'}`, coop === 'same-origin' ? 'pass' : 'fail');
                log('header-results', `Cross-Origin Isolated: ${self.crossOriginIsolated}`, self.crossOriginIsolated ? 'pass' : 'fail');
                
                // Additional header diagnostics
                log('header-results', `Current URL: ${location.href}`, 'info');
                log('header-results', `Protocol: ${location.protocol}`, location.protocol === 'https:' ? 'pass' : 'warn');
                
            } catch (error) {
                log('header-results', `‚ùå Error checking headers: ${error.message}`, 'fail');
            }
        }

        // Test 3: Browser Capabilities
        function testCapabilities() {
            log('capability-results', 'üßÆ Testing Browser Capabilities...', 'info');
            
            const caps = {};
            
            // Core web platform features
            caps.sharedArrayBuffer = typeof SharedArrayBuffer !== 'undefined';
            caps.atomics = typeof Atomics !== 'undefined';
            caps.webWorkers = typeof Worker !== 'undefined';
            caps.webAssembly = typeof WebAssembly !== 'undefined';
            caps.wasmStreaming = typeof WebAssembly.instantiateStreaming === 'function';
            caps.crossOriginIsolated = self.crossOriginIsolated;
            caps.secureContext = self.isSecureContext;
            
            // Additional features
            caps.bigInt = typeof BigInt !== 'undefined';
            caps.simdSupport = 'WebAssembly' in window && 'instantiate' in WebAssembly;
            
            Object.entries(caps).forEach(([key, value]) => {
                log('capability-results', `${key}: ${value}`, value ? 'pass' : 'fail');
            });
            
            testResults.capabilities = caps;
        }

        // Test 4: WASM Module Loading
        async function testWasmLoading() {
            clearResults('wasm-loading-results');
            log('wasm-loading-results', '‚öôÔ∏è Testing WASM Module Loading...', 'info');
            
            try {
                // Test direct import from static files
                log('wasm-loading-results', 'Attempting direct import from /wasm/...', 'info');
                wasmModule = await import('/wasm/vectorize_wasm.js');
                log('wasm-loading-results', '‚úì WASM module imported successfully', 'pass');
                
                // Initialize WASM with proper URL for web target
                const wasmUrl = new URL('/wasm/vectorize_wasm_bg.wasm', import.meta.url);
                
                if (typeof wasmModule.default === 'function') {
                    await wasmModule.default(wasmUrl);
                    log('wasm-loading-results', '‚úì WASM initialized with default()', 'pass');
                } else if (typeof wasmModule.init === 'function') {
                    await wasmModule.init(wasmUrl);
                    log('wasm-loading-results', '‚úì WASM initialized with init()', 'pass');
                } else {
                    log('wasm-loading-results', '‚ö†Ô∏è No initialization function found', 'warn');
                }
                
                // Initialize thread pool if cross-origin isolated
                if (self.crossOriginIsolated && wasmModule.initThreadPool) {
                    try {
                        const threadCount = navigator.hardwareConcurrency || 4;
                        await wasmModule.initThreadPool(threadCount);
                        log('wasm-loading-results', `‚úì Thread pool initialized with ${threadCount} threads`, 'pass');
                    } catch (error) {
                        log('wasm-loading-results', `‚ö†Ô∏è Thread pool init failed: ${error.message}`, 'warn');
                    }
                } else if (!self.crossOriginIsolated) {
                    log('wasm-loading-results', '‚ÑπÔ∏è Not cross-origin isolated, running single-threaded', 'info');
                } else {
                    log('wasm-loading-results', '‚ö†Ô∏è initThreadPool function not available', 'warn');
                }
                
                // Check available exports
                const exports = Object.keys(wasmModule).filter(key => !key.startsWith('__'));
                log('wasm-loading-results', `Available exports: ${exports.join(', ')}`, exports.length > 0 ? 'pass' : 'warn');
                
                // Check for main classes
                if (wasmModule.WasmVectorizer) {
                    log('wasm-loading-results', '‚úì WasmVectorizer class available', 'pass');
                } else {
                    log('wasm-loading-results', '‚ùå WasmVectorizer class missing', 'fail');
                }
                
                // Check for backend enums
                if (wasmModule.WasmBackend) {
                    const backends = Object.keys(wasmModule.WasmBackend);
                    log('wasm-loading-results', `Backends: ${backends.join(', ')}`, 'pass');
                } else {
                    log('wasm-loading-results', '‚ö†Ô∏è WasmBackend enum missing', 'warn');
                }
                
                // Enable other test buttons
                document.getElementById('threading-btn').disabled = false;
                document.getElementById('processing-btn').disabled = false;
                
                testResults.wasm.loading = 'success';
                
            } catch (error) {
                log('wasm-loading-results', `‚ùå WASM loading failed: ${error.message}`, 'fail');
                log('wasm-loading-results', `Error details: ${error.stack}`, 'fail');
                testResults.wasm.loading = 'failed';
                testResults.wasm.error = error.message;
            }
        }

        // Test 5: Threading Support
        async function testWasmThreading() {
            clearResults('threading-results');
            log('threading-results', 'üßµ Testing WASM Threading...', 'info');
            
            if (!wasmModule) {
                log('threading-results', '‚ùå WASM module not loaded. Run WASM loading test first.', 'fail');
                return;
            }
            
            try {
                // Check for threading functions
                const threadingFunctions = [
                    'is_threading_supported',
                    'init_threading', 
                    'get_thread_count',
                    'set_thread_count'
                ];
                
                const available = {};
                threadingFunctions.forEach(func => {
                    available[func] = typeof wasmModule[func] === 'function';
                    log('threading-results', `${func}: ${available[func] ? 'Available' : 'Missing'}`, 
                        available[func] ? 'pass' : 'warn');
                });
                
                // Test threading support
                if (wasmModule.is_threading_supported) {
                    const threadingSupported = wasmModule.is_threading_supported();
                    log('threading-results', `Threading Supported: ${threadingSupported}`, threadingSupported ? 'pass' : 'fail');
                    
                    if (threadingSupported && wasmModule.init_threading) {
                        try {
                            await wasmModule.init_threading();
                            log('threading-results', '‚úì Threading initialized successfully', 'pass');
                            
                            if (wasmModule.get_thread_count) {
                                const threadCount = wasmModule.get_thread_count();
                                log('threading-results', `Active thread count: ${threadCount}`, 'pass');
                            }
                        } catch (error) {
                            log('threading-results', `‚ùå Threading init failed: ${error.message}`, 'fail');
                        }
                    } else {
                        log('threading-results', 'Threading support detected but initialization not available', 'warn');
                    }
                } else {
                    log('threading-results', 'No threading support detection available', 'warn');
                }
                
                testResults.wasm.threading = available;
                
            } catch (error) {
                log('threading-results', `‚ùå Threading test failed: ${error.message}`, 'fail');
            }
        }

        // Test 6: Processing Performance
        async function testProcessing() {
            if (!wasmModule) {
                log('threading-results', '‚ùå WASM module not loaded. Run WASM loading test first.', 'fail');
                return;
            }
            
            log('threading-results', '‚ö° Testing Processing Performance...', 'info');
            
            try {
                // Create test image data
                const width = 100;
                const height = 100;
                const pixels = new Uint8ClampedArray(width * height * 4);
                
                // Create a simple pattern
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const intensity = Math.sin(x * 0.1) * Math.sin(y * 0.1) * 127 + 127;
                        pixels[i] = intensity;     // R
                        pixels[i + 1] = intensity; // G
                        pixels[i + 2] = intensity; // B
                        pixels[i + 3] = 255;       // A
                    }
                }
                
                const imageData = new ImageData(pixels, width, height);
                log('threading-results', `‚úì Test image created (${width}x${height})`, 'pass');
                
                // Performance test
                const start = performance.now();
                const vectorizer = new wasmModule.WasmVectorizer();
                const svg = vectorizer.vectorize(imageData);
                const end = performance.now();
                
                const processingTime = end - start;
                log('threading-results', `‚úì Processing completed in ${processingTime.toFixed(2)}ms`, 'pass');
                log('threading-results', `‚úì SVG output size: ${svg.length} characters`, 'pass');
                
                vectorizer.free();
                log('threading-results', '‚úì Memory freed', 'pass');
                
                testResults.wasm.performance = {
                    processingTimeMs: processingTime,
                    outputSize: svg.length,
                    imageSize: `${width}x${height}`
                };
                
            } catch (error) {
                log('threading-results', `‚ùå Processing test failed: ${error.message}`, 'fail');
            }
        }

        // Test 7: Vectorization
        async function testVectorization() {
            clearResults('vectorization-results');
            log('vectorization-results', 'üéØ Testing Basic Vectorization...', 'info');
            
            if (!wasmModule) {
                log('vectorization-results', '‚ùå WASM module not loaded. Run WASM loading test first.', 'fail');
                return;
            }
            
            try {
                // Create simple test image
                const size = 20;
                const pixels = new Uint8ClampedArray(size * size * 4);
                pixels.fill(255); // All white
                
                // Add a black square in the center
                for (let y = 5; y < 15; y++) {
                    for (let x = 5; x < 15; x++) {
                        const i = (y * size + x) * 4;
                        pixels[i] = 0;     // R
                        pixels[i + 1] = 0; // G
                        pixels[i + 2] = 0; // B
                        pixels[i + 3] = 255; // A
                    }
                }
                
                const imageData = new ImageData(pixels, size, size);
                log('vectorization-results', `‚úì Test pattern created (${size}x${size} with black square)`, 'pass');
                
                const vectorizer = new wasmModule.WasmVectorizer();
                const svg = vectorizer.vectorize(imageData);
                
                log('vectorization-results', `‚úì Vectorization successful`, 'pass');
                log('vectorization-results', `‚úì Output: ${svg.length} characters`, 'pass');
                
                // Validate SVG content
                if (svg.includes('<svg') && svg.includes('</svg>')) {
                    log('vectorization-results', '‚úì Valid SVG structure detected', 'pass');
                } else {
                    log('vectorization-results', '‚ö†Ô∏è SVG structure validation failed', 'warn');
                }
                
                vectorizer.free();
                
                // Display sample of output
                const preview = svg.length > 200 ? svg.substring(0, 200) + '...' : svg;
                log('vectorization-results', `Sample output: ${preview}`, 'info');
                
            } catch (error) {
                log('vectorization-results', `‚ùå Vectorization failed: ${error.message}`, 'fail');
            }
        }

        // Test 8: All Backends
        async function testAllBackends() {
            if (!wasmModule) {
                log('vectorization-results', '‚ùå WASM module not loaded. Run WASM loading test first.', 'fail');
                return;
            }
            
            log('vectorization-results', 'üîÑ Testing All Backends...', 'info');
            
            try {
                const backends = wasmModule.WasmBackend ? Object.keys(wasmModule.WasmBackend) : ['Edge'];
                log('vectorization-results', `Available backends: ${backends.join(', ')}`, 'info');
                
                // Simple test image
                const pixels = new Uint8ClampedArray(16); // 2x2 image
                pixels.fill(255);
                const imageData = new ImageData(pixels, 2, 2);
                
                for (const backend of backends) {
                    try {
                        const vectorizer = new wasmModule.WasmVectorizer();
                        
                        // Set backend if possible
                        if (wasmModule.WasmBackend && vectorizer.set_backend) {
                            vectorizer.set_backend(wasmModule.WasmBackend[backend]);
                        }
                        
                        const svg = vectorizer.vectorize(imageData);
                        log('vectorization-results', `‚úì ${backend} backend: ${svg.length} chars`, 'pass');
                        
                        vectorizer.free();
                        
                    } catch (backendError) {
                        log('vectorization-results', `‚ùå ${backend} backend failed: ${backendError.message}`, 'fail');
                    }
                }
                
            } catch (error) {
                log('vectorization-results', `‚ùå Backend testing failed: ${error.message}`, 'fail');
            }
        }

        // Generate recommendations
        function generateRecommendations() {
            const recs = [];
            
            // Header recommendations
            if (!testResults.headers.crossOriginIsolated) {
                recs.push('üîß Enable cross-origin isolation: Add COEP: require-corp and COOP: same-origin headers to your server configuration');
            }
            
            // Browser capability recommendations
            if (!testResults.capabilities.sharedArrayBuffer) {
                recs.push('üì± SharedArrayBuffer unavailable: Threading will be disabled. Enable cross-origin isolation to unlock threading features');
            }
            
            if (!testResults.capabilities.secureContext) {
                recs.push('üîí Insecure context detected: Use HTTPS or localhost for full WASM capabilities');
            }
            
            // Browser-specific recommendations
            const userAgent = testResults.environment.userAgent || '';
            if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                recs.push('üçé Safari detected: Some WASM threading features may have limited support. Consider Chrome/Firefox for development');
            }
            
            // Performance recommendations
            if (testResults.environment.hardwareConcurrency < 2) {
                recs.push('‚ö° Single-core system: Threading benefits will be minimal');
            }
            
            if (testResults.environment.deviceMemory && testResults.environment.deviceMemory < 4) {
                recs.push('üíæ Low memory detected: Consider processing smaller images or reducing quality settings');
            }
            
            // WASM-specific recommendations
            if (testResults.wasm.loading === 'failed') {
                recs.push('üîß WASM loading failed: Check that wasm files are properly served and paths are correct');
            }
            
            if (testResults.wasm.threading && !testResults.wasm.threading.is_threading_supported) {
                recs.push('üßµ Threading functions missing: WASM module may be compiled without threading support');
            }
            
            // Success state
            if (recs.length === 0) {
                recs.push('‚úÖ System appears fully optimized for WASM processing with threading support!');
            }
            
            testResults.recommendations = recs;
            
            const recsEl = document.getElementById('recommendations');
            recsEl.innerHTML = '<h3>System Analysis:</h3>';
            recs.forEach(rec => {
                recsEl.innerHTML += `<div class="info" style="margin: 10px 0; padding: 8px; background: #333; border-radius: 4px;">${rec}</div>`;
            });
            
            // Add summary
            const summary = {
                environment: Object.keys(testResults.environment).length > 0 ? 'detected' : 'pending',
                headers: testResults.headers.crossOriginIsolated ? 'optimal' : 'needs_configuration',
                capabilities: testResults.capabilities.webAssembly ? 'supported' : 'unsupported',
                wasm: testResults.wasm.loading || 'not_tested',
                threading: testResults.capabilities.sharedArrayBuffer ? 'available' : 'disabled'
            };
            
            logPre('recommendations', 'Test Summary', summary);
        }

        // Initialize all tests on load
        window.addEventListener('load', async () => {
            try {
                testEnvironment();
                await testHeaders();
                testCapabilities();
                generateRecommendations();
                
                // Auto-run WASM loading test
                await new Promise(resolve => setTimeout(resolve, 1000)); // Brief delay for readability
                await testWasmLoading();
                
            } catch (error) {
                console.error('Test initialization failed:', error);
            }
        });

        // Utility function to run all tests in sequence
        async function runAllTests() {
            await testWasmLoading();
            await testWasmThreading();
            await testProcessing();
            await testVectorization();
            await testAllBackends();
            generateRecommendations();
        }
        
        // Add global function for console access
        window.runAllTests = runAllTests;
        window.testResults = testResults;
    </script>
</body>
</html>