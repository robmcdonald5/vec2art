//! SVG generation with gradient support
//!
//! This module extends the basic SVG generation to support linear and radial gradients
//! based on the gradient detection analysis results.

use crate::algorithms::gradient_detection::{GradientType, GradientAnalysis, GradientStop, generate_gradient_id};
use crate::algorithms::logo::{SvgPath, SvgElementType};
use crate::config::SvgConfig;
use crate::preprocessing::lab_to_rgb;
use std::collections::HashMap;

/// Enhanced SVG document with gradient definitions
#[derive(Debug, Clone)]
pub struct SvgDocument {
    /// SVG paths and elements
    pub paths: Vec<SvgPath>,
    /// Gradient definitions
    pub gradients: Vec<GradientDefinition>,
    /// Document dimensions
    pub width: u32,
    pub height: u32,
}

/// SVG gradient definition
#[derive(Debug, Clone)]
pub enum GradientDefinition {
    /// Linear gradient definition
    Linear {
        id: String,
        x1: f32, y1: f32,
        x2: f32, y2: f32,
        stops: Vec<ColorStop>,
    },
    /// Radial gradient definition
    Radial {
        id: String,
        cx: f32, cy: f32,
        r: f32,
        stops: Vec<ColorStop>,
    },
}

/// Color stop for SVG gradients
#[derive(Debug, Clone)]
pub struct ColorStop {
    /// Position along gradient (0-100%)
    pub offset: f32,
    /// Color in RGB format
    pub color: String,
    /// Optional opacity
    pub opacity: Option<f32>,
}

/// Generate complete SVG document with gradient support
///
/// # Arguments
/// * `paths` - Vector of SVG paths to include
/// * `gradients` - Gradient analysis results for regions
/// * `width` - SVG viewport width
/// * `height` - SVG viewport height
/// * `config` - SVG generation configuration
///
/// # Returns
/// * `String` - Complete SVG document with gradients
pub fn generate_svg_document_with_gradients(
    paths: &[SvgPath],
    gradients: &HashMap<usize, GradientAnalysis>,
    width: u32,
    height: u32,
    config: &SvgConfig,
) -> String {
    let mut svg = String::new();

    // SVG header
    svg.push_str(&format!(
        r#"<svg width="{}" height="{}" viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg""#,
        width, height, width, height
    ));

    if config.optimize {
        svg.push_str(r#" shape-rendering="geometricPrecision""#);
    }

    svg.push_str(">\n");

    if config.include_comments {
        svg.push_str("  <!-- Generated by vec2art vectorize-core with gradient support -->\n");
    }

    // Add gradient definitions
    let gradient_definitions = generate_gradient_definitions(gradients);
    if !gradient_definitions.is_empty() {
        svg.push_str("  <defs>\n");
        for definition in &gradient_definitions {
            svg.push_str("    ");
            svg.push_str(&format_gradient_definition(definition, config));
            svg.push('\n');
        }
        svg.push_str("  </defs>\n");
    }

    // Group paths if requested
    if config.group_paths && !paths.is_empty() {
        svg.push_str("  <g>\n");
    }

    // Add each path
    for path in paths {
        if config.group_paths {
            svg.push_str("    ");
        } else {
            svg.push_str("  ");
        }

        svg.push_str(&format_svg_path(path, config));
        svg.push('\n');
    }

    if config.group_paths && !paths.is_empty() {
        svg.push_str("  </g>\n");
    }

    svg.push_str("</svg>");
    svg
}

/// Generate gradient definitions from analysis results
fn generate_gradient_definitions(gradients: &HashMap<usize, GradientAnalysis>) -> Vec<GradientDefinition> {
    let mut definitions = Vec::new();

    for (&region_id, analysis) in gradients {
        if !analysis.use_gradient {
            continue;
        }

        match &analysis.gradient_type {
            GradientType::Linear { start, end, stops, .. } => {
                let stops = convert_gradient_stops(stops);
                definitions.push(GradientDefinition::Linear {
                    id: generate_gradient_id(region_id, "linear"),
                    x1: start.x,
                    y1: start.y,
                    x2: end.x,
                    y2: end.y,
                    stops,
                });
            },
            GradientType::Radial { center, radius, stops, .. } => {
                let stops = convert_gradient_stops(stops);
                definitions.push(GradientDefinition::Radial {
                    id: generate_gradient_id(region_id, "radial"),
                    cx: center.x,
                    cy: center.y,
                    r: *radius,
                    stops,
                });
            },
            GradientType::None => {}
        }
    }

    definitions
}

/// Convert gradient stops from LAB to RGB format
fn convert_gradient_stops(gradient_stops: &[GradientStop]) -> Vec<ColorStop> {
    gradient_stops.iter().map(|stop| {
        let (r, g, b) = lab_to_rgb(stop.color.0, stop.color.1, stop.color.2);
        ColorStop {
            offset: stop.offset * 100.0, // Convert to percentage
            color: format!("rgb({},{},{})", r, g, b),
            opacity: None,
        }
    }).collect()
}

/// Format a gradient definition as SVG
fn format_gradient_definition(definition: &GradientDefinition, config: &SvgConfig) -> String {
    let precision = config.decimal_precision as usize;

    match definition {
        GradientDefinition::Linear { id, x1, y1, x2, y2, stops } => {
            let mut gradient = format!(
                r#"<linearGradient id="{}" x1="{:.prec$}" y1="{:.prec$}" x2="{:.prec$}" y2="{:.prec$}" gradientUnits="userSpaceOnUse">"#,
                id, x1, y1, x2, y2, prec = precision
            );

            for stop in stops {
                gradient.push_str(&format!(
                    r#"<stop offset="{:.1}%" stop-color="{}""#,
                    stop.offset, stop.color
                ));
                if let Some(opacity) = stop.opacity {
                    gradient.push_str(&format!(r#" stop-opacity="{:.2}""#, opacity));
                }
                gradient.push_str(" />");
            }

            gradient.push_str("</linearGradient>");
            gradient
        },
        GradientDefinition::Radial { id, cx, cy, r, stops } => {
            let mut gradient = format!(
                r#"<radialGradient id="{}" cx="{:.prec$}" cy="{:.prec$}" r="{:.prec$}" gradientUnits="userSpaceOnUse">"#,
                id, cx, cy, r, prec = precision
            );

            for stop in stops {
                gradient.push_str(&format!(
                    r#"<stop offset="{:.1}%" stop-color="{}""#,
                    stop.offset, stop.color
                ));
                if let Some(opacity) = stop.opacity {
                    gradient.push_str(&format!(r#" stop-opacity="{:.2}""#, opacity));
                }
                gradient.push_str(" />");
            }

            gradient.push_str("</radialGradient>");
            gradient
        }
    }
}

/// Format a single SVG element with potential gradient reference
fn format_svg_path(path: &SvgPath, config: &SvgConfig) -> String {
    let mut element = match &path.element_type {
        SvgElementType::Path => {
            let mut el = String::from("<path");
            el.push_str(&format!(r#" d="{}""#, path.path_data));
            el
        }
        SvgElementType::Circle { cx, cy, r } => {
            let mut el = String::from("<circle");
            el.push_str(&format!(r#" cx="{:.prec$}" cy="{:.prec$}" r="{:.prec$}""#, 
                cx, cy, r, prec = config.decimal_precision as usize));
            el
        }
        SvgElementType::Ellipse { cx, cy, rx, ry, angle } => {
            let mut el = String::from("<ellipse");
            el.push_str(&format!(r#" cx="{:.prec$}" cy="{:.prec$}" rx="{:.prec$}" ry="{:.prec$}""#,
                cx, cy, rx, ry, prec = config.decimal_precision as usize));
            if let Some(angle_deg) = angle {
                let angle_deg = angle_deg.to_degrees();
                if angle_deg.abs() > 0.1 {
                    el.push_str(&format!(r#" transform="rotate({:.1} {:.prec$} {:.prec$})""#,
                        angle_deg, cx, cy, prec = config.decimal_precision as usize));
                }
            }
            el
        }
    };

    // Add fill attribute (may be gradient reference)
    if let Some(ref fill) = path.fill {
        element.push_str(&format!(r#" fill="{}""#, fill));
    } else {
        element.push_str(r#" fill="none""#);
    }

    // Add stroke attributes
    if let Some(ref stroke) = path.stroke {
        element.push_str(&format!(r#" stroke="{}""#, stroke));
    }

    if let Some(stroke_width) = path.stroke_width {
        let width_str = if config.decimal_precision == 0 {
            format!("{:.0}", stroke_width)
        } else {
            format!(
                "{:.prec$}",
                stroke_width,
                prec = config.decimal_precision as usize
            )
        };
        element.push_str(&format!(r#" stroke-width="{}""#, width_str));
    }

    element.push_str(" />");
    element
}

/// Create an SVG path with gradient fill reference
pub fn create_path_with_gradient_fill(
    path_data: String,
    gradient_id: &str,
    stroke: Option<String>,
    stroke_width: Option<f32>,
) -> SvgPath {
    SvgPath {
        path_data,
        fill: Some(format!("url(#{})", gradient_id)),
        stroke,
        stroke_width,
        element_type: SvgElementType::Path,
    }
}

/// Create an SVG circle with gradient fill reference
pub fn create_circle_with_gradient_fill(
    cx: f32, cy: f32, r: f32,
    gradient_id: &str,
    stroke: Option<String>,
    stroke_width: Option<f32>,
) -> SvgPath {
    SvgPath {
        path_data: String::new(), // Not used for circles
        fill: Some(format!("url(#{})", gradient_id)),
        stroke,
        stroke_width,
        element_type: SvgElementType::Circle { cx, cy, r },
    }
}

/// Estimate SVG file size with gradients
pub fn estimate_svg_size_with_gradients(
    paths: &[SvgPath],
    gradients: &HashMap<usize, GradientAnalysis>,
) -> usize {
    let base_size = 150; // SVG header/footer
    let path_size: usize = paths.iter().map(|p| p.path_data.len() + 50).sum();
    
    let gradient_size: usize = gradients.values()
        .filter(|a| a.use_gradient)
        .map(|a| match &a.gradient_type {
            GradientType::Linear { stops, .. } => 80 + stops.len() * 30,
            GradientType::Radial { stops, .. } => 80 + stops.len() * 30,
            GradientType::None => 0,
        })
        .sum();
    
    base_size + path_size + gradient_size
}

/// Calculate potential file size savings from using gradients
pub fn calculate_gradient_savings(
    gradients: &HashMap<usize, GradientAnalysis>,
) -> i32 {
    gradients.values()
        .filter(|a| a.use_gradient)
        .map(|a| a.size_benefit)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algorithms::gradient_detection::{GradientType, GradientStop};
    use crate::algorithms::logo::Point;

    #[test]
    fn test_generate_gradient_id() {
        let id = generate_gradient_id(42, "linear");
        assert_eq!(id, "gradient-linear-42");
    }

    #[test]
    fn test_convert_gradient_stops() {
        let gradient_stops = vec![
            GradientStop {
                offset: 0.0,
                color: (50.0, 0.0, 0.0), // LAB color
            },
            GradientStop {
                offset: 1.0,
                color: (80.0, 10.0, -5.0), // LAB color
            },
        ];

        let svg_stops = convert_gradient_stops(&gradient_stops);
        
        assert_eq!(svg_stops.len(), 2);
        assert!((svg_stops[0].offset - 0.0).abs() < 0.01);
        assert!((svg_stops[1].offset - 100.0).abs() < 0.01);
        assert!(svg_stops[0].color.starts_with("rgb("));
        assert!(svg_stops[1].color.starts_with("rgb("));
    }

    #[test]
    fn test_create_path_with_gradient_fill() {
        let path = create_path_with_gradient_fill(
            "M 0 0 L 10 10 Z".to_string(),
            "gradient-linear-1",
            None,
            None,
        );

        assert_eq!(path.fill, Some("url(#gradient-linear-1)".to_string()));
        assert_eq!(path.path_data, "M 0 0 L 10 10 Z");
    }

    #[test]
    fn test_create_circle_with_gradient_fill() {
        let circle = create_circle_with_gradient_fill(
            50.0, 50.0, 25.0,
            "gradient-radial-2",
            Some("black".to_string()),
            Some(2.0),
        );

        assert_eq!(circle.fill, Some("url(#gradient-radial-2)".to_string()));
        assert_eq!(circle.stroke, Some("black".to_string()));
        
        if let SvgElementType::Circle { cx, cy, r } = circle.element_type {
            assert!((cx - 50.0).abs() < 0.01);
            assert!((cy - 50.0).abs() < 0.01);
            assert!((r - 25.0).abs() < 0.01);
        } else {
            // Use assert! for test code to maintain test semantics
            panic!("Expected Circle element type");
        }
    }

    #[test]
    fn test_format_gradient_definition_linear() {
        let definition = GradientDefinition::Linear {
            id: "test-linear".to_string(),
            x1: 0.0, y1: 0.0,
            x2: 100.0, y2: 0.0,
            stops: vec![
                ColorStop {
                    offset: 0.0,
                    color: "rgb(255,0,0)".to_string(),
                    opacity: None,
                },
                ColorStop {
                    offset: 100.0,
                    color: "rgb(0,0,255)".to_string(),
                    opacity: Some(0.8),
                },
            ],
        };

        let config = SvgConfig::default();
        let svg = format_gradient_definition(&definition, &config);
        
        assert!(svg.contains(r#"<linearGradient id="test-linear""#));
        assert!(svg.contains(r#"x1="0.00" y1="0.00" x2="100.00" y2="0.00""#));
        assert!(svg.contains(r#"<stop offset="0.0%" stop-color="rgb(255,0,0)""#));
        assert!(svg.contains(r#"<stop offset="100.0%" stop-color="rgb(0,0,255)" stop-opacity="0.80""#));
        assert!(svg.contains("</linearGradient>"));
    }

    #[test]
    fn test_format_gradient_definition_radial() {
        let definition = GradientDefinition::Radial {
            id: "test-radial".to_string(),
            cx: 50.0, cy: 50.0,
            r: 30.0,
            stops: vec![
                ColorStop {
                    offset: 0.0,
                    color: "rgb(255,255,255)".to_string(),
                    opacity: None,
                },
                ColorStop {
                    offset: 100.0,
                    color: "rgb(0,0,0)".to_string(),
                    opacity: None,
                },
            ],
        };

        let config = SvgConfig::default();
        let svg = format_gradient_definition(&definition, &config);
        
        assert!(svg.contains(r#"<radialGradient id="test-radial""#));
        assert!(svg.contains(r#"cx="50.00" cy="50.00" r="30.00""#));
        assert!(svg.contains(r#"<stop offset="0.0%" stop-color="rgb(255,255,255)""#));
        assert!(svg.contains(r#"<stop offset="100.0%" stop-color="rgb(0,0,0)""#));
        assert!(svg.contains("</radialGradient>"));
    }

    #[test]
    fn test_estimate_svg_size_with_gradients() {
        let paths = vec![
            SvgPath {
                path_data: "M 0 0 L 10 10 Z".to_string(),
                fill: Some("url(#gradient-1)".to_string()),
                stroke: None,
                stroke_width: None,
                element_type: SvgElementType::Path,
            }
        ];

        let mut gradients = HashMap::new();
        gradients.insert(1, GradientAnalysis {
            gradient_type: GradientType::Linear {
                start: Point { x: 0.0, y: 0.0 },
                end: Point { x: 10.0, y: 0.0 },
                stops: vec![
                    GradientStop { offset: 0.0, color: (50.0, 0.0, 0.0) },
                    GradientStop { offset: 1.0, color: (80.0, 0.0, 0.0) },
                ],
                r_squared: 0.95,
            },
            use_gradient: true,
            size_benefit: 10,
        });

        let size = estimate_svg_size_with_gradients(&paths, &gradients);
        
        // Should include base size + path size + gradient size
        assert!(size > 200); // Base + path + gradient overhead
    }
}