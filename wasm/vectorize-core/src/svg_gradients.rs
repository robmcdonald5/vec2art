//! SVG generation with gradient support
//!
//! This module provides functionality to generate SVG documents with gradient definitions
//! based on gradient analysis results from the trace-low algorithm.

use crate::algorithms::{SvgElementType, SvgPath};
use crate::config::SvgConfig;

/// SVG gradient definition
#[derive(Debug, Clone)]
pub enum GradientDefinition {
    /// Linear gradient definition
    Linear {
        id: String,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        stops: Vec<ColorStop>,
    },
    /// Radial gradient definition
    Radial {
        id: String,
        cx: f32,
        cy: f32,
        r: f32,
        stops: Vec<ColorStop>,
    },
}

/// Color stop for SVG gradients
#[derive(Debug, Clone)]
pub struct ColorStop {
    /// Position along gradient (0-100%)
    pub offset: f32,
    /// Color in RGB hex format
    pub color: String,
    /// Optional opacity
    pub opacity: Option<f32>,
}

/// Generate complete SVG document with gradient support
///
/// # Arguments
/// * `paths` - Vector of SVG paths to include
/// * `gradients` - Gradient definitions
/// * `width` - SVG viewport width
/// * `height` - SVG viewport height
/// * `config` - SVG generation configuration
///
/// # Returns
/// * `String` - Complete SVG document with gradients
pub fn generate_svg_document_with_gradients(
    paths: &[SvgPath],
    gradients: &[GradientDefinition],
    width: u32,
    height: u32,
    config: &SvgConfig,
) -> String {
    let mut svg = String::new();

    // SVG header
    svg.push_str(&format!(
        r#"<svg width="{}" height="{}" viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg""#,
        width, height, width, height
    ));

    if config.optimize {
        svg.push_str(r#" shape-rendering="geometricPrecision""#);
    }

    svg.push_str(">\n");

    if config.include_metadata {
        svg.push_str("  <!-- Generated by vec2art vectorize-core with gradient support -->\n");
    }

    // Add gradient definitions
    if !gradients.is_empty() {
        svg.push_str("  <defs>\n");
        for gradient in gradients {
            svg.push_str("    ");
            svg.push_str(&format_gradient_definition(gradient, config));
            svg.push('\n');
        }
        svg.push_str("  </defs>\n");
    }

    // Add each path
    for path in paths {
        svg.push_str("  ");
        svg.push_str(&format_svg_path(path, config));
        svg.push('\n');
    }

    svg.push_str("</svg>");

    // Apply optimization if enabled
    if config.optimize {
        crate::svg::optimize_colored_svg(&svg, !gradients.is_empty(), config.precision)
    } else {
        svg
    }
}

/// Generate optimized SVG document with advanced compression
///
/// # Arguments
/// * `paths` - Vector of SVG paths to include
/// * `gradients` - Gradient definitions
/// * `width` - SVG viewport width
/// * `height` - SVG viewport height
/// * `config` - SVG generation configuration
/// * `enable_compression` - Whether to apply aggressive compression
///
/// # Returns
/// * `(String, f32)` - Optimized SVG document and compression ratio
pub fn generate_optimized_svg_document_with_gradients(
    paths: &[SvgPath],
    gradients: &[GradientDefinition],
    width: u32,
    height: u32,
    config: &SvgConfig,
    enable_compression: bool,
) -> (String, f32) {
    let original_svg =
        generate_svg_document_with_gradients(paths, gradients, width, height, config);

    if !enable_compression {
        return (original_svg, 0.0);
    }

    // Apply advanced optimization
    let optimized_svg =
        crate::svg::optimize_colored_svg(&original_svg, !gradients.is_empty(), config.precision);

    let compression_ratio = crate::svg::calculate_compression_ratio(&original_svg, &optimized_svg);

    (optimized_svg, compression_ratio)
}

/// Format a gradient definition as SVG
fn format_gradient_definition(gradient: &GradientDefinition, _config: &SvgConfig) -> String {
    match gradient {
        GradientDefinition::Linear {
            id,
            x1,
            y1,
            x2,
            y2,
            stops,
        } => {
            let mut def = format!(
                r#"<linearGradient id="{}" x1="{}" y1="{}" x2="{}" y2="{}">"#,
                id, x1, y1, x2, y2
            );

            for stop in stops {
                def.push_str(&format!(
                    r#"<stop offset="{}%" stop-color="{}""#,
                    stop.offset, stop.color
                ));
                if let Some(opacity) = stop.opacity {
                    def.push_str(&format!(r#" stop-opacity="{}""#, opacity));
                }
                def.push_str("/>");
            }

            def.push_str("</linearGradient>");
            def
        }
        GradientDefinition::Radial {
            id,
            cx,
            cy,
            r,
            stops,
        } => {
            let mut def = format!(
                r#"<radialGradient id="{}" cx="{}" cy="{}" r="{}">"#,
                id, cx, cy, r
            );

            for stop in stops {
                def.push_str(&format!(
                    r#"<stop offset="{}%" stop-color="{}""#,
                    stop.offset, stop.color
                ));
                if let Some(opacity) = stop.opacity {
                    def.push_str(&format!(r#" stop-opacity="{}""#, opacity));
                }
                def.push_str("/>");
            }

            def.push_str("</radialGradient>");
            def
        }
    }
}

/// Format a single SVG path element
fn format_svg_path(path: &SvgPath, config: &SvgConfig) -> String {
    let mut element = match &path.element_type {
        SvgElementType::Path => {
            let mut el = String::from("<path");
            el.push_str(&format!(r#" d="{}""#, path.data));
            el
        }
        SvgElementType::Circle { cx, cy, r } => {
            let mut el = String::from("<circle");
            el.push_str(&format!(
                r#" cx="{:.prec$}" cy="{:.prec$}" r="{:.prec$}""#,
                cx,
                cy,
                r,
                prec = config.precision as usize
            ));
            el
        }
        SvgElementType::Ellipse { cx, cy, rx, ry } => {
            let mut el = String::from("<ellipse");
            el.push_str(&format!(
                r#" cx="{:.prec$}" cy="{:.prec$}" rx="{:.prec$}" ry="{:.prec$}""#,
                cx,
                cy,
                rx,
                ry,
                prec = config.precision as usize
            ));
            el
        }
        SvgElementType::Line { x1, y1, x2, y2 } => {
            let mut el = String::from("<line");
            el.push_str(&format!(
                r#" x1="{:.prec$}" y1="{:.prec$}" x2="{:.prec$}" y2="{:.prec$}""#,
                x1,
                y1,
                x2,
                y2,
                prec = config.precision as usize
            ));
            el
        }
    };

    // Add fill attribute
    if path.fill != "none" {
        element.push_str(&format!(r#" fill="{}""#, path.fill));
    } else {
        element.push_str(r#" fill="none""#);
    }

    // Add stroke attribute
    if path.stroke != "none" {
        element.push_str(&format!(r#" stroke="{}""#, path.stroke));
    }

    // Add stroke-width
    if path.stroke_width > 0.0 {
        element.push_str(&format!(r#" stroke-width="{}""#, path.stroke_width));
    }

    element.push_str(" />");
    element
}
