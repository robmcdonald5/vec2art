//! Phase A → Phase B Pipeline Validation Tests
//!
//! This module implements comprehensive end-to-end testing of the Phase A → Phase B
//! pipeline, ensuring that SVG paths generated by Phase A algorithms are compatible
//! with Phase B refinement infrastructure and produce improved quality outputs.
//!
//! ## Test Coverage
//!
//! - **Logo Algorithm Pipeline**: Binary tracing → refinement → quality validation
//! - **Regions Algorithm Pipeline**: Color quantization → refinement → quality validation
//! - **Trace-Low Pipeline**: Edge detection → refinement → quality validation
//! - **Path Compatibility**: SvgPath format compatibility across phases
//! - **Configuration Integration**: Phase A configs → Phase B RefineConfig
//! - **Error Handling**: Graceful degradation and failure recovery

use crate::algorithms::logo::{SvgPath, vectorize_logo};
use crate::algorithms::regions::vectorize_regions;
use crate::algorithms::trace_low::vectorize_trace_low;
use crate::refine::{RefineConfig, refine_vectorization};
use crate::{LogoConfig, RegionsConfig, TraceLowConfig, TraceBackend};
use crate::error::VectorizeResult;
use image::{ImageBuffer, Rgba};
use std::time::Instant;
use serde::{Serialize, Deserialize};

/// Configuration for pipeline testing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineTestConfig {
    /// Algorithm-specific configurations
    pub logo_config: LogoConfig,
    pub regions_config: RegionsConfig,
    pub trace_low_config: TraceLowConfig,
    
    /// Phase B refinement configuration
    pub refine_config: RefineConfig,
    
    /// Enable detailed validation
    pub validate_path_compatibility: bool,
    pub validate_quality_improvement: bool,
    pub validate_performance: bool,
    
    /// Test-specific parameters
    pub max_test_duration_ms: u64,
    pub min_paths_expected: usize,
}

impl Default for PipelineTestConfig {
    fn default() -> Self {
        Self {
            logo_config: LogoConfig::default(),
            regions_config: RegionsConfig::default(),
            trace_low_config: TraceLowConfig::default(),
            refine_config: RefineConfig::default(),
            validate_path_compatibility: true,
            validate_quality_improvement: true,
            validate_performance: true,
            max_test_duration_ms: 5000, // 5 seconds max per test
            min_paths_expected: 1,
        }
    }
}

/// Result of a single pipeline test
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineTestResult {
    /// Algorithm tested
    pub algorithm: String,
    
    /// Test image path
    pub image_path: String,
    
    /// Phase A execution results
    pub phase_a: PhaseExecutionResult,
    
    /// Phase B execution results  
    pub phase_b: PhaseExecutionResult,
    
    /// Path compatibility validation
    pub path_compatibility: PathCompatibilityResult,
    
    /// Quality improvement validation
    pub quality_improvement: QualityImprovementResult,
    
    /// Performance validation
    pub performance: PerformanceResult,
    
    /// Overall success status
    pub success: bool,
    
    /// Error messages if failed
    pub errors: Vec<String>,
}

/// Phase execution results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhaseExecutionResult {
    /// Execution duration in milliseconds
    pub duration_ms: u64,
    
    /// Number of paths generated
    pub path_count: usize,
    
    /// Total path points
    pub total_points: usize,
    
    /// Memory usage estimate (bytes)
    pub memory_usage_estimate: usize,
    
    /// Success status
    pub success: bool,
    
    /// Error message if failed
    pub error: Option<String>,
}

/// Path compatibility validation results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PathCompatibilityResult {
    /// All Phase A paths compatible with Phase B
    pub all_paths_compatible: bool,
    
    /// Number of compatible paths
    pub compatible_paths: usize,
    
    /// Number of incompatible paths
    pub incompatible_paths: usize,
    
    /// Compatibility issues found
    pub compatibility_issues: Vec<String>,
    
    /// Path format validation success
    pub format_validation_success: bool,
}

/// Quality improvement validation results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QualityImprovementResult {
    /// Quality measured successfully
    pub measurement_success: bool,
    
    /// Phase A baseline quality (ΔE)
    pub phase_a_delta_e: Option<f64>,
    
    /// Phase B refined quality (ΔE)
    pub phase_b_delta_e: Option<f64>,
    
    /// Quality improvement achieved
    pub delta_e_improvement: Option<f64>,
    
    /// Phase A baseline SSIM
    pub phase_a_ssim: Option<f64>,
    
    /// Phase B refined SSIM
    pub phase_b_ssim: Option<f64>,
    
    /// SSIM improvement achieved
    pub ssim_improvement: Option<f64>,
    
    /// Meets quality targets (ΔE ≤ 6.0, SSIM ≥ 0.93)
    pub meets_quality_targets: bool,
}

/// Performance validation results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceResult {
    /// Phase A performance within limits (≤ 2.5s)
    pub phase_a_within_limits: bool,
    
    /// Phase B performance within limits (≤ 600ms)
    pub phase_b_within_limits: bool,
    
    /// Combined performance within limits (≤ 3.1s)
    pub combined_within_limits: bool,
    
    /// Total pipeline duration
    pub total_duration_ms: u64,
}

/// Test logo algorithm → Phase B refinement pipeline
/// 
/// This function tests the complete pipeline from logo vectorization through
/// Phase B refinement, validating path compatibility, quality improvement,
/// and performance targets.
/// 
/// # Arguments
/// * `image_path` - Path to test image
/// * `refine_config` - Phase B refinement configuration
/// 
/// # Returns
/// * `VectorizeResult<PipelineTestResult>` - Comprehensive pipeline test results
/// 
/// # Validation
/// * SvgPath compatibility between phases
/// * Quality improvement through refinement
/// * Performance targets: Phase A ≤ 2.5s, Phase B ≤ 600ms, Combined ≤ 3.1s
pub async fn test_logo_to_refinement_pipeline(
    image_path: &str,
    refine_config: &RefineConfig,
) -> VectorizeResult<PipelineTestResult> {
    let start_time = Instant::now();
    
    // Load test image
    let image = load_test_image(image_path)?;
    
    // Initialize result structure
    let mut result = PipelineTestResult {
        algorithm: "logo".to_string(),
        image_path: image_path.to_string(),
        phase_a: PhaseExecutionResult::new(),
        phase_b: PhaseExecutionResult::new(),
        path_compatibility: PathCompatibilityResult::new(),
        quality_improvement: QualityImprovementResult::new(),
        performance: PerformanceResult::new(),
        success: true,
        errors: Vec::new(),
    };
    
    // Phase A: Logo vectorization
    log::debug!("Testing logo algorithm Phase A for {}", image_path);
    let phase_a_start = Instant::now();
    
    let logo_config = LogoConfig::default();
    let phase_a_paths = match vectorize_logo(&image, &logo_config) {
        Ok(paths) => {
            result.phase_a.success = true;
            result.phase_a.duration_ms = phase_a_start.elapsed().as_millis() as u64;
            result.phase_a.path_count = paths.len();
            result.phase_a.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_a.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase A failed: {}", e));
            result.phase_a.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Validate Phase A output
    if phase_a_paths.is_empty() {
        result.success = false;
        result.errors.push("Phase A produced no paths".to_string());
        return Ok(result);
    }
    
    // Path Compatibility Validation
    log::debug!("Validating path compatibility for Phase B refinement");
    result.path_compatibility = validate_path_compatibility(&phase_a_paths);
    
    if !result.path_compatibility.all_paths_compatible {
        result.success = false;
        result.errors.push("Path compatibility validation failed".to_string());
    }
    
    // Phase B: Refinement
    log::debug!("Testing Phase B refinement for logo paths");
    let phase_b_start = Instant::now();
    
    let phase_b_paths = match refine_vectorization(&phase_a_paths, &image, refine_config) {
        Ok(paths) => {
            result.phase_b.success = true;
            result.phase_b.duration_ms = phase_b_start.elapsed().as_millis() as u64;
            result.phase_b.path_count = paths.len();
            result.phase_b.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_b.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase B failed: {}", e));
            result.phase_b.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Quality Improvement Validation
    log::debug!("Measuring quality improvement");
    result.quality_improvement = measure_quality_improvement(&phase_a_paths, &phase_b_paths, &image)?;
    
    if !result.quality_improvement.measurement_success {
        result.success = false;
        result.errors.push("Quality measurement failed".to_string());
    }
    
    // Performance Validation
    let total_duration = start_time.elapsed().as_millis() as u64;
    result.performance = PerformanceResult {
        phase_a_within_limits: result.phase_a.duration_ms <= 2500,
        phase_b_within_limits: result.phase_b.duration_ms <= 600,
        combined_within_limits: total_duration <= 3100,
        total_duration_ms: total_duration,
    };
    
    if !result.performance.combined_within_limits {
        result.success = false;
        result.errors.push(format!("Performance targets exceeded: {}ms > 3100ms", total_duration));
    }
    
    log::info!("Logo → Refinement pipeline test completed: success={}, duration={}ms", 
              result.success, total_duration);
    
    Ok(result)
}

/// Test regions algorithm → Phase B refinement pipeline
/// 
/// This function tests the complete pipeline from regions vectorization through
/// Phase B refinement, with special attention to gradient handling and region
/// compatibility with refinement infrastructure.
/// 
/// # Arguments
/// * `image_path` - Path to test image
/// * `refine_config` - Phase B refinement configuration
/// 
/// # Returns
/// * `VectorizeResult<PipelineTestResult>` - Comprehensive pipeline test results
/// 
/// # Special Validation
/// * Gradient fill compatibility with Phase B rasterization
/// * SLIC superpixel region handling in refinement
/// * Wu quantization color preservation through refinement
pub async fn test_regions_to_refinement_pipeline(
    image_path: &str,
    refine_config: &RefineConfig,
) -> VectorizeResult<PipelineTestResult> {
    let start_time = Instant::now();
    
    // Load test image
    let image = load_test_image(image_path)?;
    
    // Initialize result structure
    let mut result = PipelineTestResult {
        algorithm: "regions".to_string(),
        image_path: image_path.to_string(),
        phase_a: PhaseExecutionResult::new(),
        phase_b: PhaseExecutionResult::new(),
        path_compatibility: PathCompatibilityResult::new(),
        quality_improvement: QualityImprovementResult::new(),
        performance: PerformanceResult::new(),
        success: true,
        errors: Vec::new(),
    };
    
    // Phase A: Regions vectorization
    log::debug!("Testing regions algorithm Phase A for {}", image_path);
    let phase_a_start = Instant::now();
    
    let mut regions_config = RegionsConfig::default();
    // Ensure reasonable config for testing
    regions_config.num_colors = 8;
    regions_config.detect_gradients = true; // Test gradient handling
    
    let phase_a_paths = match vectorize_regions(&image, &regions_config) {
        Ok(paths) => {
            result.phase_a.success = true;
            result.phase_a.duration_ms = phase_a_start.elapsed().as_millis() as u64;
            result.phase_a.path_count = paths.len();
            result.phase_a.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_a.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase A failed: {}", e));
            result.phase_a.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Validate Phase A output
    if phase_a_paths.is_empty() {
        result.success = false;
        result.errors.push("Phase A produced no paths".to_string());
        return Ok(result);
    }
    
    // Path Compatibility Validation (regions-specific)
    log::debug!("Validating regions path compatibility for Phase B refinement");
    result.path_compatibility = validate_regions_path_compatibility(&phase_a_paths);
    
    if !result.path_compatibility.all_paths_compatible {
        result.success = false;
        result.errors.push("Regions path compatibility validation failed".to_string());
    }
    
    // Phase B: Refinement
    log::debug!("Testing Phase B refinement for regions paths");
    let phase_b_start = Instant::now();
    
    let phase_b_paths = match refine_vectorization(&phase_a_paths, &image, refine_config) {
        Ok(paths) => {
            result.phase_b.success = true;
            result.phase_b.duration_ms = phase_b_start.elapsed().as_millis() as u64;
            result.phase_b.path_count = paths.len();
            result.phase_b.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_b.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase B failed: {}", e));
            result.phase_b.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Quality Improvement Validation
    log::debug!("Measuring regions quality improvement");
    result.quality_improvement = measure_quality_improvement(&phase_a_paths, &phase_b_paths, &image)?;
    
    if !result.quality_improvement.measurement_success {
        result.success = false;
        result.errors.push("Quality measurement failed".to_string());
    }
    
    // Performance Validation
    let total_duration = start_time.elapsed().as_millis() as u64;
    result.performance = PerformanceResult {
        phase_a_within_limits: result.phase_a.duration_ms <= 2500,
        phase_b_within_limits: result.phase_b.duration_ms <= 600,
        combined_within_limits: total_duration <= 3100,
        total_duration_ms: total_duration,
    };
    
    if !result.performance.combined_within_limits {
        result.success = false;
        result.errors.push(format!("Performance targets exceeded: {}ms > 3100ms", total_duration));
    }
    
    log::info!("Regions → Refinement pipeline test completed: success={}, duration={}ms", 
              result.success, total_duration);
    
    Ok(result)
}

/// Test trace-low algorithm → Phase B refinement pipeline
/// 
/// This function tests the complete pipeline from trace-low vectorization through
/// Phase B refinement, focusing on edge detection compatibility and sparse
/// path refinement.
/// 
/// # Arguments
/// * `image_path` - Path to test image
/// * `refine_config` - Phase B refinement configuration
/// 
/// # Returns
/// * `VectorizeResult<PipelineTestResult>` - Comprehensive pipeline test results
/// 
/// # Special Validation
/// * Edge-detected path compatibility with Phase B
/// * Sparse path handling in refinement 
/// * Performance optimization for low-detail output
pub async fn test_trace_low_to_refinement_pipeline(
    image_path: &str,
    refine_config: &RefineConfig,
) -> VectorizeResult<PipelineTestResult> {
    let start_time = Instant::now();
    
    // Load test image
    let image = load_test_image(image_path)?;
    
    // Initialize result structure
    let mut result = PipelineTestResult {
        algorithm: "trace-low".to_string(),
        image_path: image_path.to_string(),
        phase_a: PhaseExecutionResult::new(),
        phase_b: PhaseExecutionResult::new(),
        path_compatibility: PathCompatibilityResult::new(),
        quality_improvement: QualityImprovementResult::new(),
        performance: PerformanceResult::new(),
        success: true,
        errors: Vec::new(),
    };
    
    // Phase A: Trace-low vectorization
    log::debug!("Testing trace-low algorithm Phase A for {}", image_path);
    let phase_a_start = Instant::now();
    
    let mut trace_config = TraceLowConfig::default();
    trace_config.backend = TraceBackend::Edge; // Use edge backend for testing
    trace_config.detail = 0.3; // Medium detail level
    
    let phase_a_paths = match vectorize_trace_low(&image, &trace_config) {
        Ok(paths) => {
            result.phase_a.success = true;
            result.phase_a.duration_ms = phase_a_start.elapsed().as_millis() as u64;
            result.phase_a.path_count = paths.len();
            result.phase_a.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_a.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase A failed: {}", e));
            result.phase_a.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Note: Trace-low might produce empty results for some images (this is normal)
    if phase_a_paths.is_empty() {
        log::info!("Trace-low produced no paths for {} (normal for some images)", image_path);
        // This is not necessarily a failure for trace-low
        result.success = true;
        result.quality_improvement.measurement_success = false;
        return Ok(result);
    }
    
    // Path Compatibility Validation
    log::debug!("Validating trace-low path compatibility for Phase B refinement");
    result.path_compatibility = validate_path_compatibility(&phase_a_paths);
    
    if !result.path_compatibility.all_paths_compatible {
        result.success = false;
        result.errors.push("Path compatibility validation failed".to_string());
    }
    
    // Phase B: Refinement
    log::debug!("Testing Phase B refinement for trace-low paths");
    let phase_b_start = Instant::now();
    
    let phase_b_paths = match refine_vectorization(&phase_a_paths, &image, refine_config) {
        Ok(paths) => {
            result.phase_b.success = true;
            result.phase_b.duration_ms = phase_b_start.elapsed().as_millis() as u64;
            result.phase_b.path_count = paths.len();
            result.phase_b.total_points = paths.iter().map(|p| estimate_path_points(p)).sum();
            result.phase_b.memory_usage_estimate = estimate_paths_memory(&paths);
            paths
        }
        Err(e) => {
            result.success = false;
            result.errors.push(format!("Phase B failed: {}", e));
            result.phase_b.error = Some(e.to_string());
            return Ok(result);
        }
    };
    
    // Quality Improvement Validation
    log::debug!("Measuring trace-low quality improvement");
    result.quality_improvement = measure_quality_improvement(&phase_a_paths, &phase_b_paths, &image)?;
    
    if !result.quality_improvement.measurement_success {
        result.success = false;
        result.errors.push("Quality measurement failed".to_string());
    }
    
    // Performance Validation
    let total_duration = start_time.elapsed().as_millis() as u64;
    result.performance = PerformanceResult {
        phase_a_within_limits: result.phase_a.duration_ms <= 2500,
        phase_b_within_limits: result.phase_b.duration_ms <= 600,
        combined_within_limits: total_duration <= 3100,
        total_duration_ms: total_duration,
    };
    
    if !result.performance.combined_within_limits {
        result.success = false;
        result.errors.push(format!("Performance targets exceeded: {}ms > 3100ms", total_duration));
    }
    
    log::info!("Trace-low → Refinement pipeline test completed: success={}, duration={}ms", 
              result.success, total_duration);
    
    Ok(result)
}

// Helper function implementations

impl PhaseExecutionResult {
    fn new() -> Self {
        Self {
            duration_ms: 0,
            path_count: 0,
            total_points: 0,
            memory_usage_estimate: 0,
            success: false,
            error: None,
        }
    }
}

impl PathCompatibilityResult {
    fn new() -> Self {
        Self {
            all_paths_compatible: true,
            compatible_paths: 0,
            incompatible_paths: 0,
            compatibility_issues: Vec::new(),
            format_validation_success: true,
        }
    }
}

impl QualityImprovementResult {
    fn new() -> Self {
        Self {
            measurement_success: false,
            phase_a_delta_e: None,
            phase_b_delta_e: None,
            delta_e_improvement: None,
            phase_a_ssim: None,
            phase_b_ssim: None,
            ssim_improvement: None,
            meets_quality_targets: false,
        }
    }
}

impl PerformanceResult {
    fn new() -> Self {
        Self {
            phase_a_within_limits: false,
            phase_b_within_limits: false,
            combined_within_limits: false,
            total_duration_ms: 0,
        }
    }
}

/// Validate that Phase A paths are compatible with Phase B refinement
fn validate_path_compatibility(paths: &[SvgPath]) -> PathCompatibilityResult {
    let mut result = PathCompatibilityResult::new();
    
    for (i, path) in paths.iter().enumerate() {
        // Check path format validity
        if !is_valid_svg_path(path) {
            result.all_paths_compatible = false;
            result.incompatible_paths += 1;
            result.compatibility_issues.push(format!("Path {} has invalid format", i));
            continue;
        }
        
        // Check Phase B compatibility
        if !is_phase_b_compatible(path) {
            result.all_paths_compatible = false;
            result.incompatible_paths += 1;
            result.compatibility_issues.push(format!("Path {} not compatible with Phase B", i));
            continue;
        }
        
        result.compatible_paths += 1;
    }
    
    result.format_validation_success = result.compatibility_issues.is_empty();
    result
}

/// Validate that regions-specific paths are compatible with Phase B refinement
fn validate_regions_path_compatibility(paths: &[SvgPath]) -> PathCompatibilityResult {
    let mut result = validate_path_compatibility(paths);
    
    // Additional regions-specific validation
    for (i, path) in paths.iter().enumerate() {
        // Check gradient fill compatibility
        if let Some(fill) = &path.fill {
            if fill.contains("gradient") {
                // Validate gradient format
                if !is_gradient_phase_b_compatible(path) {
                    result.all_paths_compatible = false;
                    result.incompatible_paths += 1;
                    result.compatibility_issues.push(
                        format!("Path {} gradient not compatible with Phase B rasterization", i)
                    );
                }
            }
        }
    }
    
    result
}

/// Load test image from various possible locations
fn load_test_image(image_path: &str) -> VectorizeResult<ImageBuffer<Rgba<u8>, Vec<u8>>> {
    use crate::error::VectorizeError;
    
    // Try common test image locations
    let test_paths = [
        format!("examples/images/{}", image_path),
        format!("wasm/examples/images/{}", image_path),
        format!("../examples/images/{}", image_path),
        image_path.to_string(), // Direct path
    ];
    
    for path in &test_paths {
        if let Ok(img) = image::open(path) {
            return Ok(img.to_rgba8());
        }
    }
    
    Err(VectorizeError::algorithm_error(format!("Could not load test image: {}", image_path)))
}

/// Measure quality improvement between Phase A and Phase B
fn measure_quality_improvement(
    phase_a_paths: &[SvgPath],
    phase_b_paths: &[SvgPath],
    original_image: &ImageBuffer<Rgba<u8>, Vec<u8>>,
) -> VectorizeResult<QualityImprovementResult> {
    use crate::refine::rasterize::rasterize_svg_paths;
    use crate::config::SvgConfig;
    
    let mut result = QualityImprovementResult::new();
    let svg_config = SvgConfig::default();
    
    // Measure Phase A quality
    match rasterize_svg_paths(phase_a_paths, original_image.width(), original_image.height(), &svg_config) {
        Ok(phase_a_raster) => {
            if let Ok((delta_e, ssim)) = calculate_quality_metrics(&phase_a_raster, original_image) {
                result.phase_a_delta_e = Some(delta_e);
                result.phase_a_ssim = Some(ssim);
            }
        }
        Err(e) => {
            log::warn!("Failed to rasterize Phase A paths: {}", e);
            return Ok(result);
        }
    }
    
    // Measure Phase B quality
    match rasterize_svg_paths(phase_b_paths, original_image.width(), original_image.height(), &svg_config) {
        Ok(phase_b_raster) => {
            if let Ok((delta_e, ssim)) = calculate_quality_metrics(&phase_b_raster, original_image) {
                result.phase_b_delta_e = Some(delta_e);
                result.phase_b_ssim = Some(ssim);
                
                // Calculate improvements
                if let (Some(a_delta_e), Some(a_ssim)) = (result.phase_a_delta_e, result.phase_a_ssim) {
                    result.delta_e_improvement = Some(a_delta_e - delta_e); // Positive = improvement
                    result.ssim_improvement = Some(ssim - a_ssim); // Positive = improvement
                    
                    // Check quality targets
                    result.meets_quality_targets = delta_e <= 6.0 && ssim >= 0.93;
                    result.measurement_success = true;
                }
            }
        }
        Err(e) => {
            log::warn!("Failed to rasterize Phase B paths: {}", e);
            return Ok(result);
        }
    }
    
    Ok(result)
}

/// Calculate quality metrics (ΔE and SSIM)
fn calculate_quality_metrics(
    rasterized: &ImageBuffer<Rgba<u8>, Vec<u8>>,
    original: &ImageBuffer<Rgba<u8>, Vec<u8>>,
) -> Result<(f64, f64), Box<dyn std::error::Error>> {
    use crate::refine::error::compute_tile_errors;
    use crate::refine::error::TileAnalysisConfig;
    
    let tile_config = TileAnalysisConfig {
        tile_size: 32,
        max_tiles_per_iteration: 100, // Large number to analyze whole image
        delta_e_threshold: 10.0, // High threshold to get all tiles
        ssim_threshold: 0.0,     // Low threshold to get all tiles
        use_content_weighting: true,
    };
    
    let tile_errors = compute_tile_errors(original, rasterized, &tile_config)?;
    
    if tile_errors.is_empty() {
        return Ok((0.0, 1.0)); // Perfect match
    }
    
    // Calculate average metrics
    let avg_delta_e = tile_errors.iter().map(|t| t.delta_e_avg).sum::<f64>() / tile_errors.len() as f64;
    let avg_ssim = tile_errors.iter().map(|t| t.ssim).sum::<f64>() / tile_errors.len() as f64;
    
    Ok((avg_delta_e, avg_ssim))
}

/// Helper functions for path validation

fn is_valid_svg_path(path: &SvgPath) -> bool {
    // Basic SVG path validation
    !path.path_data.is_empty() && 
    (path.fill.is_some() || path.stroke.is_some()) &&
    path.stroke_width.map_or(true, |w| w >= 0.0)
}

fn is_phase_b_compatible(path: &SvgPath) -> bool {
    // Check that path can be rasterized by Phase B
    // All current Phase A paths should be compatible
    true // Placeholder - Phase B should handle all Phase A outputs
}

fn is_gradient_phase_b_compatible(path: &SvgPath) -> bool {
    // Check that gradient fills work with Phase B rasterization
    // This validates gradient format compatibility
    true // Placeholder - gradients should be compatible
}

fn estimate_path_points(path: &SvgPath) -> usize {
    // Estimate number of control points in path
    // This is a rough estimate for memory calculations
    path.path_data.len() / 10 // Rough estimate based on path data length
}

fn estimate_paths_memory(paths: &[SvgPath]) -> usize {
    // Estimate memory usage of paths
    paths.iter().map(|p| {
        std::mem::size_of::<SvgPath>() + 
        p.path_data.len() + 
        p.fill.as_ref().map_or(0, |f| f.len()) +
        p.stroke.as_ref().map_or(0, |s| s.len())
    }).sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pipeline_test_config_defaults() {
        let config = PipelineTestConfig::default();
        assert_eq!(config.max_test_duration_ms, 5000);
        assert_eq!(config.min_paths_expected, 1);
        assert!(config.validate_path_compatibility);
    }
    
    #[test]
    fn test_phase_execution_result_new() {
        let result = PhaseExecutionResult::new();
        assert_eq!(result.duration_ms, 0);
        assert_eq!(result.path_count, 0);
        assert!(!result.success);
        assert!(result.error.is_none());
    }
    
    #[test] 
    fn test_path_compatibility_result_new() {
        let result = PathCompatibilityResult::new();
        assert!(result.all_paths_compatible);
        assert_eq!(result.compatible_paths, 0);
        assert_eq!(result.incompatible_paths, 0);
        assert!(result.format_validation_success);
    }
    
    #[test]
    fn test_quality_improvement_result_new() {
        let result = QualityImprovementResult::new();
        assert!(!result.measurement_success);
        assert!(result.phase_a_delta_e.is_none());
        assert!(!result.meets_quality_targets);
    }
    
    #[test]
    fn test_performance_result_new() {
        let result = PerformanceResult::new();
        assert!(!result.phase_a_within_limits);
        assert!(!result.phase_b_within_limits);
        assert!(!result.combined_within_limits);
        assert_eq!(result.total_duration_ms, 0);
    }
}