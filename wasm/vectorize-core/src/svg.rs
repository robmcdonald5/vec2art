//! SVG generation utilities

use crate::algorithms::logo::SvgPath;
use crate::config::SvgConfig;

/// Generate complete SVG document from paths
///
/// # Arguments
/// * `paths` - Vector of SVG paths to include
/// * `width` - SVG viewport width
/// * `height` - SVG viewport height
/// * `config` - SVG generation configuration
///
/// # Returns
/// * `String` - Complete SVG document
pub fn generate_svg_document(
    paths: &[SvgPath],
    width: u32,
    height: u32,
    config: &SvgConfig,
) -> String {
    let mut svg = String::new();

    // SVG header
    svg.push_str(&format!(
        r#"<svg width="{}" height="{}" viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg""#,
        width, height, width, height
    ));

    if config.optimize {
        svg.push_str(r#" shape-rendering="geometricPrecision""#);
    }

    svg.push_str(">\n");

    if config.include_comments {
        svg.push_str("  <!-- Generated by vec2art vectorize-core -->\n");
    }

    // Group paths if requested
    if config.group_paths && !paths.is_empty() {
        svg.push_str("  <g>\n");
    }

    // Add each path
    for path in paths {
        if config.group_paths {
            svg.push_str("    ");
        } else {
            svg.push_str("  ");
        }

        svg.push_str(&format_svg_path(path, config));
        svg.push('\n');
    }

    if config.group_paths && !paths.is_empty() {
        svg.push_str("  </g>\n");
    }

    svg.push_str("</svg>");
    svg
}

/// Format a single SVG path element
fn format_svg_path(path: &SvgPath, config: &SvgConfig) -> String {
    let mut element = String::from("<path");

    // Add path data
    element.push_str(&format!(r#" d="{}""#, path.path_data));

    // Add fill attribute
    if let Some(ref fill) = path.fill {
        element.push_str(&format!(r#" fill="{}""#, fill));
    } else {
        element.push_str(r#" fill="none""#);
    }

    // Add stroke attributes
    if let Some(ref stroke) = path.stroke {
        element.push_str(&format!(r#" stroke="{}""#, stroke));
    }

    if let Some(stroke_width) = path.stroke_width {
        let width_str = if config.decimal_precision == 0 {
            format!("{:.0}", stroke_width)
        } else {
            format!(
                "{:.prec$}",
                stroke_width,
                prec = config.decimal_precision as usize
            )
        };
        element.push_str(&format!(r#" stroke-width="{}""#, width_str));
    }

    element.push_str(" />");
    element
}

/// Optimize SVG path data by removing unnecessary precision
///
/// # Arguments
/// * `path_data` - Raw SVG path data string
/// * `precision` - Decimal places to keep
///
/// # Returns
/// * `String` - Optimized path data
pub fn optimize_path_data(path_data: &str, precision: u8) -> String {
    use std::fmt::Write;

    let mut result = String::new();
    let mut chars = path_data.chars().peekable();

    while let Some(ch) = chars.next() {
        if ch.is_ascii_alphabetic() {
            // Path command - keep as is
            result.push(ch);
        } else if ch.is_ascii_digit() || ch == '.' || ch == '-' {
            // Start of a number - collect the full number
            let mut number_str = String::new();
            number_str.push(ch);

            // Collect the rest of the number
            while let Some(&next_ch) = chars.peek() {
                if next_ch.is_ascii_digit()
                    || next_ch == '.'
                    || (number_str.len() == 1 && next_ch == '-')
                {
                    number_str.push(chars.next().unwrap());
                } else {
                    break;
                }
            }

            // Parse and format with specified precision
            if let Ok(num) = number_str.parse::<f64>() {
                if precision == 0 {
                    write!(&mut result, "{:.0}", num).unwrap();
                } else {
                    let formatted = format!("{:.prec$}", num, prec = precision as usize);
                    // Remove trailing zeros after decimal point
                    let trimmed = if formatted.contains('.') {
                        formatted.trim_end_matches('0').trim_end_matches('.')
                    } else {
                        &formatted
                    };
                    result.push_str(trimmed);
                }
            } else {
                // If parsing fails, keep original
                result.push_str(&number_str);
            }
        } else if ch == ' ' || ch == ',' {
            // Space or comma - normalize to single space
            if !result.ends_with(' ') && !result.is_empty() {
                result.push(' ');
            }
        } else {
            // Other characters (like Z) - keep as is
            result.push(ch);
        }
    }

    // Clean up multiple spaces and trim
    result = result.split_whitespace().collect::<Vec<&str>>().join(" ");

    // Remove spaces around path commands where safe
    for cmd in &[
        'M', 'L', 'C', 'S', 'Q', 'T', 'A', 'H', 'V', 'Z', 'm', 'l', 'c', 's', 'q', 't', 'a', 'h',
        'v', 'z',
    ] {
        let cmd_str = cmd.to_string();
        result = result.replace(&format!(" {} ", cmd_str), &format!(" {}", cmd_str));
        result = result.replace(&format!("{} ", cmd_str), &cmd_str.to_string());
    }

    result.trim().to_string()
}

/// Calculate approximate file size of SVG
///
/// # Arguments
/// * `svg_content` - SVG document string
///
/// # Returns
/// * `usize` - Approximate file size in bytes
pub fn calculate_svg_size(svg_content: &str) -> usize {
    svg_content.len()
}

/// Minify SVG by removing unnecessary whitespace and formatting
///
/// # Arguments
/// * `svg_content` - SVG document string
///
/// # Returns
/// * `String` - Minified SVG
pub fn minify_svg(svg_content: &str) -> String {
    svg_content
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>()
        .join("")
}

/// Validate SVG paths for correctness
///
/// # Arguments
/// * `paths` - Vector of SVG paths to validate
///
/// # Returns
/// * `Result<(), String>` - Ok if valid, Err with description if invalid
pub fn validate_svg_paths(paths: &[SvgPath]) -> Result<(), String> {
    for (i, path) in paths.iter().enumerate() {
        if path.path_data.is_empty() {
            return Err(format!("Path {} has empty path data", i));
        }

        // Basic syntax validation
        if !path
            .path_data
            .chars()
            .any(|c| "MmLlHhVvCcSsQqTtAaZz".contains(c))
        {
            return Err(format!("Path {} has no valid path commands", i));
        }

        // Check for balanced quotes (basic check)
        if path.path_data.matches('"').count() % 2 != 0 {
            return Err(format!("Path {} has unmatched quotes", i));
        }
    }

    Ok(())
}

/// Create a simple rectangle path
///
/// # Arguments
/// * `x`, `y` - Top-left corner coordinates
/// * `width`, `height` - Rectangle dimensions
/// * `fill` - Optional fill color
///
/// # Returns
/// * `SvgPath` - Rectangle path
pub fn create_rectangle(x: f32, y: f32, width: f32, height: f32, fill: Option<String>) -> SvgPath {
    SvgPath {
        path_data: format!(
            "M {:.2} {:.2} h {:.2} v {:.2} h {:.2} Z",
            x, y, width, height, -width
        ),
        fill,
        stroke: None,
        stroke_width: None,
    }
}

/// Create a simple circle path using Bezier curves
///
/// # Arguments
/// * `cx`, `cy` - Center coordinates
/// * `radius` - Circle radius
/// * `fill` - Optional fill color
///
/// # Returns
/// * `SvgPath` - Circle path
pub fn create_circle(cx: f32, cy: f32, radius: f32, fill: Option<String>) -> SvgPath {
    // Use 4 cubic Bezier curves to approximate a circle
    let kappa = 0.5522847498; // Magic number for circle approximation
    let offset = radius * kappa;

    SvgPath {
        path_data: format!(
            "M {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} Z",
            cx, cy - radius,
            cx + offset, cy - radius, cx + radius, cy - offset, cx + radius, cy,
            cx + radius, cy + offset, cx + offset, cy + radius, cx, cy + radius,
            cx - offset, cy + radius, cx - radius, cy + offset, cx - radius, cy,
            cx - radius, cy - offset, cx - offset, cy - radius, cx, cy - radius
        ),
        fill,
        stroke: None,
        stroke_width: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_svg_document() {
        let paths = vec![SvgPath {
            path_data: "M 0 0 L 10 10 Z".to_string(),
            fill: Some("red".to_string()),
            stroke: None,
            stroke_width: None,
        }];

        let config = SvgConfig::default();
        let svg = generate_svg_document(&paths, 100, 100, &config);

        assert!(svg.contains("<svg"));
        assert!(svg.contains("</svg>"));
        assert!(svg.contains("M 0 0 L 10 10 Z"));
        assert!(svg.contains("fill=\"red\""));
    }

    #[test]
    fn test_validate_svg_paths() {
        let valid_paths = vec![SvgPath {
            path_data: "M 0 0 L 10 10 Z".to_string(),
            fill: Some("blue".to_string()),
            stroke: None,
            stroke_width: None,
        }];

        assert!(validate_svg_paths(&valid_paths).is_ok());

        let invalid_paths = vec![SvgPath {
            path_data: "".to_string(), // Empty path data
            fill: None,
            stroke: None,
            stroke_width: None,
        }];

        assert!(validate_svg_paths(&invalid_paths).is_err());
    }

    #[test]
    fn test_create_rectangle() {
        let rect = create_rectangle(10.0, 20.0, 30.0, 40.0, Some("green".to_string()));
        assert!(rect.path_data.contains("M 10.00 20.00"));
        assert!(rect.path_data.contains("Z"));
        assert_eq!(rect.fill, Some("green".to_string()));
    }

    #[test]
    fn test_create_circle() {
        let circle = create_circle(50.0, 50.0, 25.0, Some("yellow".to_string()));
        assert!(circle.path_data.contains("M"));
        assert!(circle.path_data.contains("C"));
        assert!(circle.path_data.contains("Z"));
        assert_eq!(circle.fill, Some("yellow".to_string()));
    }

    #[test]
    fn test_minify_svg() {
        let svg = r#"<svg width="100" height="100">
  <path d="M 0 0 L 10 10 Z" fill="red" />
</svg>"#;

        let minified = minify_svg(svg);
        assert!(!minified.contains('\n'));
        assert!(minified.len() < svg.len());
    }

    #[test]
    fn test_optimize_path_data() {
        // Test precision reduction
        let path = "M 1.23456 4.56789 L 10.00000 20.12340 Z";
        let optimized = optimize_path_data(path, 2);
        assert_eq!(optimized, "M1.23 4.57 L10 20.12 Z");

        // Test integer precision
        let optimized_int = optimize_path_data(path, 0);
        assert_eq!(optimized_int, "M1 5 L10 20 Z");

        // Test space normalization
        let messy_path = "M  1.5  ,  2.5   L   10 , 20  Z";
        let cleaned = optimize_path_data(messy_path, 1);
        assert_eq!(cleaned, "M1.5 2.5 L10 20 Z");
    }
}
