//! SVG generation utilities

use crate::algorithms::logo::SvgPath;
use crate::config::SvgConfig;

/// Generate complete SVG document from paths
///
/// # Arguments
/// * `paths` - Vector of SVG paths to include
/// * `width` - SVG viewport width
/// * `height` - SVG viewport height
/// * `config` - SVG generation configuration
///
/// # Returns
/// * `String` - Complete SVG document
pub fn generate_svg_document(
    paths: &[SvgPath],
    width: u32,
    height: u32,
    config: &SvgConfig,
) -> String {
    let mut svg = String::new();
    
    // SVG header
    svg.push_str(&format!(
        r#"<svg width="{}" height="{}" viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg""#,
        width, height, width, height
    ));
    
    if config.optimize {
        svg.push_str(r#" shape-rendering="geometricPrecision""#);
    }
    
    svg.push_str(">\n");
    
    if config.include_comments {
        svg.push_str("  <!-- Generated by vec2art vectorize-core -->\n");
    }
    
    // Group paths if requested
    if config.group_paths && !paths.is_empty() {
        svg.push_str("  <g>\n");
    }
    
    // Add each path
    for path in paths {
        if config.group_paths {
            svg.push_str("    ");
        } else {
            svg.push_str("  ");
        }
        
        svg.push_str(&format_svg_path(path, config));
        svg.push('\n');
    }
    
    if config.group_paths && !paths.is_empty() {
        svg.push_str("  </g>\n");
    }
    
    svg.push_str("</svg>");
    svg
}

/// Format a single SVG path element
fn format_svg_path(path: &SvgPath, config: &SvgConfig) -> String {
    let mut element = String::from("<path");
    
    // Add path data
    element.push_str(&format!(r#" d="{}""#, path.path_data));
    
    // Add fill attribute
    if let Some(ref fill) = path.fill {
        element.push_str(&format!(r#" fill="{}""#, fill));
    } else {
        element.push_str(r#" fill="none""#);
    }
    
    // Add stroke attributes
    if let Some(ref stroke) = path.stroke {
        element.push_str(&format!(r#" stroke="{}""#, stroke));
    }
    
    if let Some(stroke_width) = path.stroke_width {
        let width_str = if config.decimal_precision == 0 {
            format!("{:.0}", stroke_width)
        } else {
            format!("{:.prec$}", stroke_width, prec = config.decimal_precision as usize)
        };
        element.push_str(&format!(r#" stroke-width="{}""#, width_str));
    }
    
    element.push_str(" />");
    element
}

/// Optimize SVG path data by removing unnecessary precision
///
/// # Arguments
/// * `path_data` - Raw SVG path data string
/// * `precision` - Decimal places to keep
///
/// # Returns
/// * `String` - Optimized path data
pub fn optimize_path_data(path_data: &str, precision: u8) -> String {
    // TODO: Implement path data optimization
    // - Remove unnecessary decimal places
    // - Convert absolute to relative commands where beneficial
    // - Remove redundant commands
    // - Combine consecutive commands of same type
    
    if precision == 0 {
        // For now, just round to integers (placeholder)
        path_data.to_string()
    } else {
        path_data.to_string()
    }
}

/// Calculate approximate file size of SVG
///
/// # Arguments
/// * `svg_content` - SVG document string
///
/// # Returns
/// * `usize` - Approximate file size in bytes
pub fn calculate_svg_size(svg_content: &str) -> usize {
    svg_content.len()
}

/// Minify SVG by removing unnecessary whitespace and formatting
///
/// # Arguments
/// * `svg_content` - SVG document string
///
/// # Returns
/// * `String` - Minified SVG
pub fn minify_svg(svg_content: &str) -> String {
    svg_content
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>()
        .join("")
}

/// Validate SVG paths for correctness
///
/// # Arguments
/// * `paths` - Vector of SVG paths to validate
///
/// # Returns
/// * `Result<(), String>` - Ok if valid, Err with description if invalid
pub fn validate_svg_paths(paths: &[SvgPath]) -> Result<(), String> {
    for (i, path) in paths.iter().enumerate() {
        if path.path_data.is_empty() {
            return Err(format!("Path {} has empty path data", i));
        }
        
        // Basic syntax validation
        if !path.path_data.chars().any(|c| "MmLlHhVvCcSsQqTtAaZz".contains(c)) {
            return Err(format!("Path {} has no valid path commands", i));
        }
        
        // Check for balanced quotes (basic check)
        if path.path_data.matches('"').count() % 2 != 0 {
            return Err(format!("Path {} has unmatched quotes", i));
        }
    }
    
    Ok(())
}

/// Create a simple rectangle path
///
/// # Arguments
/// * `x`, `y` - Top-left corner coordinates
/// * `width`, `height` - Rectangle dimensions
/// * `fill` - Optional fill color
///
/// # Returns
/// * `SvgPath` - Rectangle path
pub fn create_rectangle(x: f32, y: f32, width: f32, height: f32, fill: Option<String>) -> SvgPath {
    SvgPath {
        path_data: format!("M {:.2} {:.2} h {:.2} v {:.2} h {:.2} Z", x, y, width, height, -width),
        fill,
        stroke: None,
        stroke_width: None,
    }
}

/// Create a simple circle path using Bezier curves
///
/// # Arguments
/// * `cx`, `cy` - Center coordinates
/// * `radius` - Circle radius
/// * `fill` - Optional fill color
///
/// # Returns
/// * `SvgPath` - Circle path
pub fn create_circle(cx: f32, cy: f32, radius: f32, fill: Option<String>) -> SvgPath {
    // Use 4 cubic Bezier curves to approximate a circle
    let kappa = 0.5522847498; // Magic number for circle approximation
    let offset = radius * kappa;
    
    SvgPath {
        path_data: format!(
            "M {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} C {:.2} {:.2} {:.2} {:.2} {:.2} {:.2} Z",
            cx, cy - radius,
            cx + offset, cy - radius, cx + radius, cy - offset, cx + radius, cy,
            cx + radius, cy + offset, cx + offset, cy + radius, cx, cy + radius,
            cx - offset, cy + radius, cx - radius, cy + offset, cx - radius, cy,
            cx - radius, cy - offset, cx - offset, cy - radius, cx, cy - radius
        ),
        fill,
        stroke: None,
        stroke_width: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_svg_document() {
        let paths = vec![
            SvgPath {
                path_data: "M 0 0 L 10 10 Z".to_string(),
                fill: Some("red".to_string()),
                stroke: None,
                stroke_width: None,
            }
        ];
        
        let config = SvgConfig::default();
        let svg = generate_svg_document(&paths, 100, 100, &config);
        
        assert!(svg.contains("<svg"));
        assert!(svg.contains("</svg>"));
        assert!(svg.contains("M 0 0 L 10 10 Z"));
        assert!(svg.contains("fill=\"red\""));
    }

    #[test]
    fn test_validate_svg_paths() {
        let valid_paths = vec![
            SvgPath {
                path_data: "M 0 0 L 10 10 Z".to_string(),
                fill: Some("blue".to_string()),
                stroke: None,
                stroke_width: None,
            }
        ];
        
        assert!(validate_svg_paths(&valid_paths).is_ok());
        
        let invalid_paths = vec![
            SvgPath {
                path_data: "".to_string(), // Empty path data
                fill: None,
                stroke: None,
                stroke_width: None,
            }
        ];
        
        assert!(validate_svg_paths(&invalid_paths).is_err());
    }

    #[test]
    fn test_create_rectangle() {
        let rect = create_rectangle(10.0, 20.0, 30.0, 40.0, Some("green".to_string()));
        assert!(rect.path_data.contains("M 10.00 20.00"));
        assert!(rect.path_data.contains("Z"));
        assert_eq!(rect.fill, Some("green".to_string()));
    }

    #[test]
    fn test_create_circle() {
        let circle = create_circle(50.0, 50.0, 25.0, Some("yellow".to_string()));
        assert!(circle.path_data.contains("M"));
        assert!(circle.path_data.contains("C"));
        assert!(circle.path_data.contains("Z"));
        assert_eq!(circle.fill, Some("yellow".to_string()));
    }

    #[test]
    fn test_minify_svg() {
        let svg = r#"<svg width="100" height="100">
  <path d="M 0 0 L 10 10 Z" fill="red" />
</svg>"#;
        
        let minified = minify_svg(svg);
        assert!(!minified.contains('\n'));
        assert!(minified.len() < svg.len());
    }
}