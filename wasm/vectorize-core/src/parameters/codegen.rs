//! TypeScript type generation from parameter registry
//!
//! This module generates TypeScript type definitions and parameter metadata
//! from the Rust parameter registry, ensuring frontend/backend type consistency.

use std::collections::BTreeMap;
use crate::algorithms::TraceBackend;
use super::registry::{PARAMETER_REGISTRY, ParameterDefinition};
use super::types::ParameterCategory;

/// Generate complete TypeScript interface definitions
pub fn generate_typescript_interfaces() -> String {
    let mut output = String::new();
    
    // Header
    output.push_str("//! Auto-generated TypeScript interfaces from Rust parameter registry\n");
    output.push_str("//! DO NOT EDIT MANUALLY - This file is generated by the build process\n");
    output.push_str("//!\n");
    output.push_str("//! Generated from: wasm/vectorize-core/src/parameters/registry.rs\n");
    output.push_str("//! Regenerate with: cargo run --bin generate-frontend-types\n\n");
    
    // Generate main VectorizerConfig interface
    generate_main_config_interface(&mut output);
    
    // Generate backend-specific interfaces
    generate_backend_interfaces(&mut output);
    
    // Generate parameter metadata
    generate_parameter_metadata(&mut output);
    
    // Generate utility types and functions
    generate_utility_types(&mut output);
    
    output
}

/// Generate the main VectorizerConfig interface
fn generate_main_config_interface(output: &mut String) {
    output.push_str("export interface VectorizerConfig {\n");
    
    // Group parameters by category for better organization
    let mut params_by_category: BTreeMap<ParameterCategory, Vec<&ParameterDefinition>> = BTreeMap::new();
    
    for def in PARAMETER_REGISTRY.values() {
        params_by_category.entry(def.category).or_default().push(def);
    }
    
    for (category, params) in params_by_category {
        output.push_str(&format!("  // ==================== {} PARAMETERS ====================\n", 
                                category.to_string().to_uppercase()));
        
        let mut sorted_params = params;
        sorted_params.sort_by_key(|p| p.name);
        
        for param in sorted_params {
            let ts_type = param.parameter_type.to_typescript();
            let optional = if param.constraints.backend_specific { "?" } else { "" };
            
            // Add JSDoc comment with parameter details
            output.push_str(&format!("  /**\n"));
            output.push_str(&format!("   * {}\n", param.description));
            if param.constraints.backend_specific {
                output.push_str(&format!("   * Applicable backends: {:?}\n", param.applicable_backends));
            }
            if !param.constraints.requires.is_empty() {
                output.push_str(&format!("   * Requires: {:?}\n", param.constraints.requires));
            }
            if !param.constraints.conflicts_with.is_empty() {
                output.push_str(&format!("   * Conflicts with: {:?}\n", param.constraints.conflicts_with));
            }
            output.push_str(&format!("   * Default: {}\n", param.default_value));
            output.push_str(&format!("   */\n"));
            
            output.push_str(&format!("  {}{}: {};\n\n", param.name, optional, ts_type));
        }
        
        output.push_str("\n");
    }
    
    output.push_str("}\n\n");
}

/// Generate backend-specific configuration interfaces
fn generate_backend_interfaces(output: &mut String) {
    let backends = [TraceBackend::Edge, TraceBackend::Centerline, TraceBackend::Superpixel, TraceBackend::Dots];
    
    for backend in backends {
        let backend_name = format!("{:?}", backend);
        
        // Get parameters applicable to this backend
        let applicable_params: Vec<&str> = PARAMETER_REGISTRY
            .values()
            .filter(|def| def.applicable_backends.contains(&backend))
            .map(|def| def.name)
            .collect();
        
        output.push_str(&format!("export interface {}BackendConfig extends Pick<VectorizerConfig,\n", backend_name));
        
        // Format parameter list nicely
        let param_list = applicable_params
            .iter()
            .map(|name| format!("  '{}'", name))
            .collect::<Vec<_>>()
            .join(" |\n");
            
        output.push_str(&format!("{}\n> {{}}\n\n", param_list));
    }
}

/// Generate parameter metadata for runtime use
fn generate_parameter_metadata(output: &mut String) {
    output.push_str("export const PARAMETER_METADATA = {\n");
    
    for def in PARAMETER_REGISTRY.values() {
        output.push_str(&format!("  '{}': {{\n", def.name));
        output.push_str(&format!("    name: '{}',\n", def.name));
        output.push_str(&format!("    description: '{}',\n", def.description));
        output.push_str(&format!("    category: '{}',\n", def.category.to_string().to_lowercase()));
        output.push_str(&format!("    applicableBackends: {:?},\n", 
                                format_backends_for_ts(&def.applicable_backends)));
        output.push_str(&format!("    backendSpecific: {},\n", def.constraints.backend_specific));
        
        // Add type-specific metadata
        match &def.parameter_type {
            super::types::ParameterType::Float { min, max, precision } => {
                output.push_str(&format!("    type: 'float',\n"));
                output.push_str(&format!("    min: {},\n", min));
                output.push_str(&format!("    max: {},\n", max));
                output.push_str(&format!("    precision: {},\n", precision));
            }
            super::types::ParameterType::Integer { min, max } => {
                output.push_str(&format!("    type: 'integer',\n"));
                output.push_str(&format!("    min: {},\n", min));
                output.push_str(&format!("    max: {},\n", max));
            }
            super::types::ParameterType::Boolean => {
                output.push_str(&format!("    type: 'boolean',\n"));
            }
            super::types::ParameterType::Enum { variants } => {
                output.push_str(&format!("    type: 'enum',\n"));
                output.push_str(&format!("    variants: {:?},\n", variants));
            }
            super::types::ParameterType::String { max_length } => {
                output.push_str(&format!("    type: 'string',\n"));
                if let Some(max_len) = max_length {
                    output.push_str(&format!("    maxLength: {},\n", max_len));
                }
            }
        }
        
        // Add constraints
        if !def.constraints.requires.is_empty() {
            output.push_str(&format!("    requires: {:?},\n", def.constraints.requires));
        }
        if !def.constraints.conflicts_with.is_empty() {
            output.push_str(&format!("    conflictsWith: {:?},\n", def.constraints.conflicts_with));
        }
        
        // Add default value
        output.push_str(&format!("    defaultValue: {},\n", format_default_value_for_ts(&def.default_value)));
        
        output.push_str("  },\n");
    }
    
    output.push_str("} as const;\n\n");
    
    // Add type for parameter metadata
    output.push_str("export type ParameterMetadata = typeof PARAMETER_METADATA[keyof typeof PARAMETER_METADATA];\n\n");
}

/// Generate utility types and helper functions
fn generate_utility_types(output: &mut String) {
    // Backend type
    output.push_str("export type VectorizerBackend = 'edge' | 'centerline' | 'superpixel' | 'dots';\n\n");
    
    // Parameter categories
    output.push_str("export type ParameterCategory = 'core' | 'quality' | 'algorithm' | 'style' | 'color' | 'advanced';\n\n");
    
    // Helper functions
    output.push_str("/**\n");
    output.push_str(" * Get all parameters applicable to a specific backend\n");
    output.push_str(" */\n");
    output.push_str("export function getParametersForBackend(backend: VectorizerBackend): string[] {\n");
    output.push_str("  return Object.keys(PARAMETER_METADATA).filter(paramName => {\n");
    output.push_str("    const metadata = PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];\n");
    output.push_str("    return metadata.applicableBackends.includes(backend);\n");
    output.push_str("  });\n");
    output.push_str("}\n\n");
    
    output.push_str("/**\n");
    output.push_str(" * Get parameters by category\n");
    output.push_str(" */\n");
    output.push_str("export function getParametersByCategory(category: ParameterCategory): string[] {\n");
    output.push_str("  return Object.keys(PARAMETER_METADATA).filter(paramName => {\n");
    output.push_str("    const metadata = PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];\n");
    output.push_str("    return metadata.category === category;\n");
    output.push_str("  });\n");
    output.push_str("}\n\n");
    
    output.push_str("/**\n");
    output.push_str(" * Get parameter metadata by name\n");
    output.push_str(" */\n");
    output.push_str("export function getParameterMetadata(paramName: string): ParameterMetadata | undefined {\n");
    output.push_str("  return PARAMETER_METADATA[paramName as keyof typeof PARAMETER_METADATA];\n");
    output.push_str("}\n\n");
    
    output.push_str("/**\n");
    output.push_str(" * Validate a parameter value against its metadata\n");
    output.push_str(" */\n");
    output.push_str("export function validateParameter(paramName: string, value: any): { valid: boolean; error?: string } {\n");
    output.push_str("  const metadata = getParameterMetadata(paramName);\n");
    output.push_str("  if (!metadata) {\n");
    output.push_str("    return { valid: false, error: `Unknown parameter: ${paramName}` };\n");
    output.push_str("  }\n");
    output.push_str("  \n");
    output.push_str("  // Type checking based on parameter metadata\n");
    output.push_str("  switch (metadata.type) {\n");
    output.push_str("    case 'float':\n");
    output.push_str("    case 'integer':\n");
    output.push_str("      if (typeof value !== 'number' || isNaN(value)) {\n");
    output.push_str("        return { valid: false, error: `${paramName} must be a number` };\n");
    output.push_str("      }\n");
    output.push_str("      if (value < metadata.min || value > metadata.max) {\n");
    output.push_str("        return { valid: false, error: `${paramName} must be between ${metadata.min} and ${metadata.max}` };\n");
    output.push_str("      }\n");
    output.push_str("      break;\n");
    output.push_str("    case 'boolean':\n");
    output.push_str("      if (typeof value !== 'boolean') {\n");
    output.push_str("        return { valid: false, error: `${paramName} must be a boolean` };\n");
    output.push_str("      }\n");
    output.push_str("      break;\n");
    output.push_str("    case 'enum':\n");
    output.push_str("      if (typeof value !== 'string' || !metadata.variants?.includes(value)) {\n");
    output.push_str("        return { valid: false, error: `${paramName} must be one of: ${metadata.variants?.join(', ')}` };\n");
    output.push_str("      }\n");
    output.push_str("      break;\n");
    output.push_str("    case 'string':\n");
    output.push_str("      if (typeof value !== 'string') {\n");
    output.push_str("        return { valid: false, error: `${paramName} must be a string` };\n");
    output.push_str("      }\n");
    output.push_str("      break;\n");
    output.push_str("  }\n");
    output.push_str("  \n");
    output.push_str("  return { valid: true };\n");
    output.push_str("}\n");
}

/// Format backends for TypeScript array
fn format_backends_for_ts(backends: &[TraceBackend]) -> String {
    let backend_strings: Vec<String> = backends
        .iter()
        .map(|b| format!("'{}'", format!("{:?}", b).to_lowercase()))
        .collect();
    format!("[{}]", backend_strings.join(", "))
}

/// Format default value for TypeScript
fn format_default_value_for_ts(value: &super::types::ParameterValue) -> String {
    match value {
        super::types::ParameterValue::Float(f) => f.to_string(),
        super::types::ParameterValue::Integer(i) => i.to_string(),
        super::types::ParameterValue::Boolean(b) => b.to_string(),
        super::types::ParameterValue::String(s) => format!("'{}'", s),
    }
}

/// Generate standalone TypeScript file with complete type definitions
pub fn generate_typescript_file() -> Result<String, String> {
    // Validate registry first
    super::registry::validate_registry_completeness()?;
    
    Ok(generate_typescript_interfaces())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_typescript_generation() {
        let typescript_code = generate_typescript_interfaces();
        
        // Check that main interface is generated
        assert!(typescript_code.contains("export interface VectorizerConfig"));
        
        // Check that backend interfaces are generated
        assert!(typescript_code.contains("EdgeBackendConfig"));
        assert!(typescript_code.contains("SuperpixelBackendConfig"));
        assert!(typescript_code.contains("DotsBackendConfig"));
        assert!(typescript_code.contains("CenterlineBackendConfig"));
        
        // Check that parameter metadata is generated
        assert!(typescript_code.contains("export const PARAMETER_METADATA"));
        
        // Check that utility functions are generated
        assert!(typescript_code.contains("export function getParametersForBackend"));
        assert!(typescript_code.contains("export function validateParameter"));
    }

    #[test]
    fn test_typescript_file_generation() {
        let result = generate_typescript_file();
        assert!(result.is_ok());
        
        let typescript_code = result.unwrap();
        assert!(!typescript_code.is_empty());
        assert!(typescript_code.contains("DO NOT EDIT MANUALLY"));
    }

    #[test]
    fn test_parameter_metadata_completeness() {
        let typescript_code = generate_typescript_interfaces();
        
        // Check that all parameters from registry are included in metadata
        for param_name in PARAMETER_REGISTRY.keys() {
            assert!(typescript_code.contains(&format!("  '{}': {{", param_name)),
                   "Parameter {} not found in generated metadata", param_name);
        }
    }
}